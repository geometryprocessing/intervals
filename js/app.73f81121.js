(function(t){function a(a){for(var r,d,l=a[0],i=a[1],_=a[2],o=0,u=[];o<l.length;o++)d=l[o],Object.prototype.hasOwnProperty.call(e,d)&&e[d]&&u.push(e[d][0]),e[d]=0;for(r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r]);p&&p(a);while(u.length)u.shift()();return s.push.apply(s,_||[]),n()}function n(){for(var t,a=0;a<s.length;a++){for(var n=s[a],r=!0,d=1;d<n.length;d++){var l=n[d];0!==e[l]&&(r=!1)}r&&(s.splice(a--,1),t=i(i.s=n[0]))}return t}var r={},d={app:0},e={app:0},s=[];function l(t){return i.p+"js/"+({about:"about"}[t]||t)+"."+{about:"6a346081"}[t]+".js"}function i(a){if(r[a])return r[a].exports;var n=r[a]={i:a,l:!1,exports:{}};return t[a].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.e=function(t){var a=[],n={about:1};d[t]?a.push(d[t]):0!==d[t]&&n[t]&&a.push(d[t]=new Promise((function(a,n){for(var r="css/"+({about:"about"}[t]||t)+"."+{about:"4ed03c21"}[t]+".css",e=i.p+r,s=document.getElementsByTagName("link"),l=0;l<s.length;l++){var _=s[l],o=_.getAttribute("data-href")||_.getAttribute("href");if("stylesheet"===_.rel&&(o===r||o===e))return a()}var u=document.getElementsByTagName("style");for(l=0;l<u.length;l++){_=u[l],o=_.getAttribute("data-href");if(o===r||o===e)return a()}var p=document.createElement("link");p.rel="stylesheet",p.type="text/css",p.onload=a,p.onerror=function(a){var r=a&&a.target&&a.target.src||e,s=new Error("Loading CSS chunk "+t+" failed.\n("+r+")");s.code="CSS_CHUNK_LOAD_FAILED",s.request=r,delete d[t],p.parentNode.removeChild(p),n(s)},p.href=e;var v=document.getElementsByTagName("head")[0];v.appendChild(p)})).then((function(){d[t]=0})));var r=e[t];if(0!==r)if(r)a.push(r[2]);else{var s=new Promise((function(a,n){r=e[t]=[a,n]}));a.push(r[2]=s);var _,o=document.createElement("script");o.charset="utf-8",o.timeout=120,i.nc&&o.setAttribute("nonce",i.nc),o.src=l(t);var u=new Error;_=function(a){o.onerror=o.onload=null,clearTimeout(p);var n=e[t];if(0!==n){if(n){var r=a&&("load"===a.type?"missing":a.type),d=a&&a.target&&a.target.src;u.message="Loading chunk "+t+" failed.\n("+r+": "+d+")",u.name="ChunkLoadError",u.type=r,u.request=d,n[1](u)}e[t]=void 0}};var p=setTimeout((function(){_({type:"timeout",target:o})}),12e4);o.onerror=o.onload=_,document.head.appendChild(o)}return Promise.all(a)},i.m=t,i.c=r,i.d=function(t,a,n){i.o(t,a)||Object.defineProperty(t,a,{enumerable:!0,get:n})},i.r=function(t){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,a){if(1&a&&(t=i(t)),8&a)return t;if(4&a&&"object"===typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&a&&"string"!=typeof t)for(var r in t)i.d(n,r,function(a){return t[a]}.bind(null,r));return n},i.n=function(t){var a=t&&t.__esModule?function(){return t["default"]}:function(){return t};return i.d(a,"a",a),a},i.o=function(t,a){return Object.prototype.hasOwnProperty.call(t,a)},i.p="/intervals/",i.oe=function(t){throw console.error(t),t};var _=window["webpackJsonp"]=window["webpackJsonp"]||[],o=_.push.bind(_);_.push=a,_=_.slice();for(var u=0;u<_.length;u++)a(_[u]);var p=o;s.push([0,"chunk-vendors"]),n()})({0:function(t,a,n){t.exports=n("56d7")},"034f":function(t,a,n){"use strict";n("85ec")},"1d87":function(t,a,n){"use strict";n("5b18")},"40ca":function(t){t.exports=JSON.parse('[{"description":"addition","expr":"X0 + X1","num_variable":"2","file_name":"addition.cpp","code":"// addition\\ntemplate <class T>\\ninline T addition(const std::vector<T> &value_array)\\n{\\n    return value_array[0] + value_array[1];\\n}\\nstd::string print_addition(const std::vector<gmp::Rational> &value_array)\\n{\\n    return rational_to_string(value_array[0]) + \\"+\\" + rational_to_string(value_array[1]);\\n}\\nbool check_input_addition(const std::vector<double> &value_array)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> addition_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int addition_variable_count = 2;","function_name":"addition","graph_name_base":"ADDITION","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.19e+02</td><td>6.13e+02</td><td>4.22e+02</td><td><b><i>2.68e+01</i></b></td><td>3.41e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.26e+01</td><td>4.05e+02</td><td>1.82e+01</td><td><b><i>3.88e+00</i></b></td><td>4.00e+00</td><td>3.27e+02</td><td>3.27e+02</td><td>3.28e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>8.43e+01</td><td>1.10e+02</td><td>2.68e+01</td><td><b><i>9.55e+00</i></b></td><td>1.05e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench sec4-example","expr":"((X0 * X1) - 1.0) / (((X0 * X1) * (X0 * X1)) - 1.0)","num_variable":"2","file_name":"sec4_example.cpp","code":"// FPBench sec4-example\\ntemplate <class T>\\ninline T sec4_example(const std::vector<T> &value_array)\\n{\\n\\treturn ((value_array[0] * value_array[1]) - 1.0) / (((value_array[0] * value_array[1]) * (value_array[0] * value_array[1])) - 1.0);\\n}\\nstd::string print_sec4_example(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (1)) / (((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - (1))\\";\\n}\\nbool check_input_sec4_example(const std::vector<double> &v)\\n{\\n    if (1.001 > v[0])\\n        return false;\\n    if (v[0] > 2.0)\\n        return false;\\n    if (1.001 > v[1])\\n        return false;\\n    if (v[1] > 2.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sec4_example_range = {std::uniform_real_distribution<double>(1.001, 2.0), std::uniform_real_distribution<double>(1.001, 2.0)};\\nconst int sec4_example_variable_count = 2;","function_name":"sec4_example","graph_name_base":"sec4-example","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.07e+03</td><td>6.56e+03</td><td>6.58e+03</td><td><b><i>1.87e+02</i></b></td><td>2.90e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.64e+02</td><td>9.21e+03</td><td>1.24e+03</td><td><b><i>2.94e+02</i></b></td><td>5.33e+02</td><td>2.33e+03</td><td>2.33e+03</td><td>2.33e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.72e+02</td><td>8.80e+02</td><td>2.90e+02</td><td><b><i>2.12e+02</i></b></td><td>3.05e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.3.3","expr":"((1.0 / (X0 + 1.0)) - (2.0 / X0)) + (1.0 / (X0 - 1.0))","num_variable":"1","file_name":"NMSE_problem_3_3_3.cpp","code":"// FPBench NMSE problem 3.3.3\\ntemplate <class T>\\ninline T NMSE_problem_3_3_3(const std::vector<T> &value_array)\\n{\\n\\treturn ((1.0 / (value_array[0] + 1.0)) - (2.0 / value_array[0])) + (1.0 / (value_array[0] - 1.0));\\n}\\nstd::string print_NMSE_problem_3_3_3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((1) / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1))) - ((2) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) + ((1) / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (1)))\\";\\n}\\nbool check_input_NMSE_problem_3_3_3(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_3_3_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_problem_3_3_3_variable_count = 1;","function_name":"NMSE_problem_3_3_3","graph_name_base":"NMSE problem 3.3.3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.07e+03</td><td>5.86e+03</td><td>5.09e+03</td><td><b><i>1.43e+02</i></b></td><td>3.14e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.01e+02</td><td>7.69e+03</td><td>1.06e+03</td><td><b><i>2.63e+02</i></b></td><td>4.21e+02</td><td>3.32e+03</td><td>3.24e+03</td><td>3.25e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.94e+02</td><td>8.71e+02</td><td>3.17e+02</td><td><b><i>2.06e+02</i></b></td><td>2.97e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.3.2","expr":"tan(X0 + X1) - tan(X0)","num_variable":"2","file_name":"NMSE_problem_3_3_2.cpp","code":"// FPBench NMSE problem 3.3.2\\ntemplate <class T>\\ninline T NMSE_problem_3_3_2(const std::vector<T> &value_array)\\n{\\n\\treturn tan(value_array[0] + value_array[1]) - tan(value_array[0]);\\n}\\nstd::string print_NMSE_problem_3_3_2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"tan(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - tan(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_problem_3_3_2(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_3_2_range = {std::uniform_real_distribution<double>((-7074237750381340.0 /  2097152.0) / 2.1, (7074237750381340.0 /  2097152.0) / 2.1), std::uniform_real_distribution<double>((-7074237750381340.0 /  2097152.0) / 2.1, (7074237750381340.0 /  2097152.0) / 2.1)};\\nconst int NMSE_problem_3_3_2_variable_count = 2;","function_name":"NMSE_problem_3_3_2","graph_name_base":"NMSE problem 3.3.2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>9.33e+02</td><td>9.36e+03</td><td>1.68e+03</td><td><b><i>6.15e+02</i></b></td><td>6.52e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.43e+02</td><td>1.54e+04</td><td>1.17e+03</td><td><b><i>6.05e+02</i></b></td><td>6.61e+02</td><td>7.09e+03</td><td>6.99e+03</td><td>6.96e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>9.66e+02</td><td>1.75e+03</td><td><b><i>5.42e+02</i></b></td><td>7.78e+02</td><td>8.27e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench intro-example-mixed","expr":"(X0 / ((X0 + 1.0)))","num_variable":"1","file_name":"intro_example_mixed.cpp","code":"// FPBench intro-example-mixed\\ntemplate <class T>\\ninline T intro_example_mixed(const std::vector<T> &value_array)\\n{\\n\\treturn (value_array[0] / ((value_array[0] + 1.0)));\\n}\\nstd::string print_intro_example_mixed(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1))))\\";\\n}\\nbool check_input_intro_example_mixed(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 999.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> intro_example_mixed_range = {std::uniform_real_distribution<double>(1.0, 999.0)};\\nconst int intro_example_mixed_variable_count = 1;","function_name":"intro_example_mixed","graph_name_base":"intro-example-mixed","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.07e+02</td><td>1.70e+03</td><td>1.51e+03</td><td><b><i>5.63e+01</i></b></td><td>7.82e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.46e+02</td><td>8.66e+02</td><td>3.78e+02</td><td><b><i>7.72e+01</i></b></td><td>1.24e+02</td><td>6.65e+02</td><td>6.65e+02</td><td>6.63e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.90e+02</td><td>2.58e+02</td><td>8.41e+01</td><td><b><i>5.46e+01</i></b></td><td>7.72e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.3.1","expr":"(1.0 / (X0 + 1.0)) - (1.0 / X0)","num_variable":"1","file_name":"NMSE_problem_3_3_1.cpp","code":"// FPBench NMSE problem 3.3.1\\ntemplate <class T>\\ninline T NMSE_problem_3_3_1(const std::vector<T> &value_array)\\n{\\n\\treturn (1.0 / (value_array[0] + 1.0)) - (1.0 / value_array[0]);\\n}\\nstd::string print_NMSE_problem_3_3_1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((1) / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1))) - ((1) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_problem_3_3_1(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_3_1_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_problem_3_3_1_variable_count = 1;","function_name":"NMSE_problem_3_3_1","graph_name_base":"NMSE problem 3.3.1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>5.91e+02</td><td>3.46e+03</td><td>3.10e+03</td><td><b><i>9.00e+01</i></b></td><td>1.79e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.30e+02</td><td>3.62e+03</td><td>2.88e+02</td><td><b><i>1.45e+02</i></b></td><td>2.29e+02</td><td>1.31e+03</td><td>1.32e+03</td><td>1.32e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.55e+02</td><td>4.69e+02</td><td>1.67e+02</td><td><b><i>1.17e+02</i></b></td><td>1.74e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench sum","expr":"(((X0 + X1) - X2) + ((X1 + X2) - X0)) + ((X2 + X0) - X1)","num_variable":"3","file_name":"sum.cpp","code":"// FPBench sum\\ntemplate <class T>\\ninline T sum(const std::vector<T> &value_array)\\n{\\n\\treturn (((value_array[0] + value_array[1]) - value_array[2]) + ((value_array[1] + value_array[2]) - value_array[0])) + ((value_array[2] + value_array[0]) - value_array[1]);\\n}\\nstd::string print_sum(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")\\";\\n}\\nbool check_input_sum(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 2.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 2.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 2.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sum_range = {std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0)};\\nconst int sum_variable_count = 3;","function_name":"sum","graph_name_base":"sum","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.19e+03</td><td>6.13e+03</td><td>5.04e+03</td><td><b><i>1.83e+02</i></b></td><td>3.10e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.95e+02</td><td>9.78e+03</td><td>1.15e+03</td><td><b><i>1.98e+02</i></b></td><td>2.03e+02</td><td>2.64e+03</td><td>2.64e+03</td><td>2.64e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.76e+02</td><td>9.22e+02</td><td>2.05e+02</td><td><b><i>1.34e+02</i></b></td><td>2.31e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench exp1x_32","expr":"(exp(X0) - 1.0) / X0","num_variable":"1","file_name":"exp1x_32.cpp","code":"// FPBench exp1x_32\\ntemplate <class T>\\ninline T exp1x_32(const std::vector<T> &value_array)\\n{\\n\\treturn (exp(value_array[0]) - 1.0) / value_array[0];\\n}\\nstd::string print_exp1x_32(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (1)) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\";\\n}\\nbool check_input_exp1x_32(const std::vector<double> &v)\\n{\\n    if (0.01 > v[0])\\n        return false;\\n    if (v[0] > 0.5)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> exp1x_32_range = {std::uniform_real_distribution<double>(0.01, 0.5)};\\nconst int exp1x_32_variable_count = 1;","function_name":"exp1x_32","graph_name_base":"exp1x_32","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.84e+02</td><td>3.40e+03</td><td>2.32e+03</td><td><b><i>3.82e+02</i></b></td><td>4.35e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.02e+02</td><td>2.86e+03</td><td><b><i>2.35e+02</i></b></td><td>2.96e+02</td><td>3.29e+02</td><td>7.98e+02</td><td>7.97e+02</td><td>7.97e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.69e+02</td><td>5.35e+02</td><td><b><i>2.66e+02</i></b></td><td>3.26e+02</td><td>3.59e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench intro-example","expr":"X0 / (X0 + 1.0)","num_variable":"1","file_name":"intro_example.cpp","code":"// FPBench intro-example\\ntemplate <class T>\\ninline T intro_example(const std::vector<T> &value_array)\\n{\\n\\treturn value_array[0] / (value_array[0] + 1.0);\\n}\\nstd::string print_intro_example(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1))\\";\\n}\\nbool check_input_intro_example(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 999.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> intro_example_range = {std::uniform_real_distribution<double>(0.0, 999.0)};\\nconst int intro_example_variable_count = 1;","function_name":"intro_example","graph_name_base":"intro-example","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.06e+02</td><td>1.83e+03</td><td>1.57e+03</td><td><b><i>5.57e+01</i></b></td><td>7.76e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.46e+02</td><td>2.43e+03</td><td><b><i>5.47e+01</i></b></td><td>7.69e+01</td><td>1.24e+02</td><td>6.66e+02</td><td>6.66e+02</td><td>6.66e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.93e+02</td><td>2.65e+02</td><td>8.64e+01</td><td><b><i>5.92e+01</i></b></td><td>7.91e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench exp1x_log","expr":"(exp(X0) - 1.0) / log(exp(X0))","num_variable":"1","file_name":"exp1x_log.cpp","code":"// FPBench exp1x_log\\ntemplate <class T>\\ninline T exp1x_log(const std::vector<T> &value_array)\\n{\\n\\treturn (exp(value_array[0]) - 1.0) / log(exp(value_array[0]));\\n}\\nstd::string print_exp1x_log(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (1)) / log(exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_exp1x_log(const std::vector<double> &v)\\n{\\n    if (0.01 > v[0])\\n        return false;\\n    if (v[0] > 0.5)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> exp1x_log_range = {std::uniform_real_distribution<double>(0.01, 0.5)};\\nconst int exp1x_log_variable_count = 1;","function_name":"exp1x_log","graph_name_base":"exp1x_log","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.15e+03</td><td>7.03e+03</td><td>3.09e+03</td><td><b><i>1.13e+03</i></b></td><td>1.19e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.11e+03</td><td>5.64e+03</td><td><b><i>7.33e+02</i></b></td><td>8.05e+02</td><td>8.11e+02</td><td>1.23e+03</td><td>1.23e+03</td><td>1.23e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.10e+03</td><td>1.05e+03</td><td><b><i>8.64e+02</i></b></td><td>8.88e+02</td><td>9.50e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.2.1, positive","expr":"(-X1 + sqrt((X1 * X1) - (X0 * X2))) / X0","num_variable":"3","file_name":"NMSE_problem_3_2_1_positive.cpp","code":"// FPBench NMSE problem 3.2.1, positive\\ntemplate <class T>\\ninline T NMSE_problem_3_2_1_positive(const std::vector<T> &value_array)\\n{\\n\\treturn (-value_array[1] + sqrt((value_array[1] * value_array[1]) - (value_array[0] * value_array[2]))) / value_array[0];\\n}\\nstd::string print_NMSE_problem_3_2_1_positive(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(-\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" + sqrt((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\";\\n}\\nbool check_input_NMSE_problem_3_2_1_positive(const std::vector<double> &v)\\n{\\n    if ((v[1] * v[1]) < (v[0] * v[2]))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_2_1_positive_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_problem_3_2_1_positive_variable_count = 3;","function_name":"NMSE_problem_3_2_1_positive","graph_name_base":"NMSE problem 3.2.1, positive","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>9.82e+02</td><td>7.13e+03</td><td>5.49e+03</td><td><b><i>2.41e+02</i></b></td><td>3.62e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.59e+02</td><td>5.79e+03</td><td>8.65e+02</td><td><b><i>3.25e+02</i></b></td><td>5.49e+02</td><td>1.92e+03</td><td>1.92e+03</td><td>1.92e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.98e+02</td><td>7.87e+02</td><td>3.30e+02</td><td><b><i>2.42e+02</i></b></td><td>3.35e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.3.5","expr":"cos(X0 + X1) - cos(X0)","num_variable":"2","file_name":"NMSE_problem_3_3_5.cpp","code":"// FPBench NMSE problem 3.3.5\\ntemplate <class T>\\ninline T NMSE_problem_3_3_5(const std::vector<T> &value_array)\\n{\\n\\treturn cos(value_array[0] + value_array[1]) - cos(value_array[0]);\\n}\\nstd::string print_NMSE_problem_3_3_5(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"cos(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - cos(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_problem_3_3_5(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_3_5_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_problem_3_3_5_variable_count = 2;","function_name":"NMSE_problem_3_3_5","graph_name_base":"NMSE problem 3.3.5","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>7.73e+02</td><td>1.06e+04</td><td>1.57e+03</td><td><b><i>4.70e+02</i></b></td><td>5.11e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.39e+02</td><td>2.02e+04</td><td><b><i>4.14e+02</i></b></td><td>4.63e+02</td><td>4.95e+02</td><td>7.31e+03</td><td>7.25e+03</td><td>7.26e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.70e+02</td><td>1.81e+03</td><td><b><i>4.03e+02</i></b></td><td>5.64e+02</td><td>6.04e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle12","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle12.cpp","code":"// FPBench triangle12\\ntemplate <class T>\\ninline T triangle12(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle12(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle12(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/1000000000000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/1000000000000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/1000000000000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle12_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle12_variable_count = 3;","function_name":"triangle12","graph_name_base":"triangle12","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.76e+04</td><td>1.34e+04</td><td><b><i>5.60e+02</i></b></td><td>9.20e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.36e+03</td><td>2.69e+04</td><td>4.80e+03</td><td><b><i>1.04e+03</i></b></td><td>1.97e+03</td><td>7.55e+03</td><td>7.57e+03</td><td>7.56e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.94e+03</td><td>2.67e+03</td><td>9.25e+02</td><td><b><i>6.32e+02</i></b></td><td>1.01e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench test05_nonlin1, r4","expr":"(X0 - 1.0) / ((X0 * X0) - 1.0)","num_variable":"1","file_name":"test05_nonlin1_r4.cpp","code":"// FPBench test05_nonlin1, r4\\ntemplate <class T>\\ninline T test05_nonlin1_r4(const std::vector<T> &value_array)\\n{\\n\\treturn (value_array[0] - 1.0) / ((value_array[0] * value_array[0]) - 1.0);\\n}\\nstd::string print_test05_nonlin1_r4(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (1)) / ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (1))\\";\\n}\\nbool check_input_test05_nonlin1_r4(const std::vector<double> &v)\\n{\\n    if (1.00001 >= v[0])\\n        return false;\\n    if (v[0] >= 2.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> test05_nonlin1_r4_range = {std::uniform_real_distribution<double>(1.00001, 2.0)};\\nconst int test05_nonlin1_r4_variable_count = 1;","function_name":"test05_nonlin1_r4","graph_name_base":"test05_nonlin1, r4","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.08e+02</td><td>3.46e+03</td><td>3.06e+03</td><td><b><i>9.53e+01</i></b></td><td>1.49e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.65e+02</td><td>6.87e+03</td><td><b><i>9.40e+01</i></b></td><td>1.54e+02</td><td>2.67e+02</td><td>1.32e+03</td><td>1.32e+03</td><td>1.32e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.68e+02</td><td>4.96e+02</td><td>1.60e+02</td><td><b><i>1.25e+02</i></b></td><td>1.62e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.3.6","expr":"log(X0 + 1.0) - log(X0)","num_variable":"1","file_name":"NMSE_problem_3_3_6.cpp","code":"// FPBench NMSE problem 3.3.6\\ntemplate <class T>\\ninline T NMSE_problem_3_3_6(const std::vector<T> &value_array)\\n{\\n\\treturn log(value_array[0] + 1.0) - log(value_array[0]);\\n}\\nstd::string print_NMSE_problem_3_3_6(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"log(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1)) - log(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_problem_3_3_6(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_3_6_range = {std::uniform_real_distribution<double>(0, RAND_MAX)};\\nconst int NMSE_problem_3_3_6_variable_count = 1;","function_name":"NMSE_problem_3_3_6","graph_name_base":"NMSE problem 3.3.6","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.11e+03</td><td>4.39e+03</td><td>1.68e+03</td><td><b><i>7.38e+02</i></b></td><td>8.44e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>9.60e+02</td><td>3.17e+03</td><td>5.52e+02</td><td><b><i>3.47e+02</i></b></td><td>3.78e+02</td><td>1.01e+03</td><td>9.40e+02</td><td>9.43e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.70e+02</td><td>6.59e+02</td><td><b><i>2.77e+02</i></b></td><td>3.78e+02</td><td>4.34e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle11","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle11.cpp","code":"// FPBench triangle11\\ntemplate <class T>\\ninline T triangle11(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle11(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle11(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/100000000000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/100000000000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/100000000000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle11_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle11_variable_count = 3;","function_name":"triangle11","graph_name_base":"triangle11","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.64e+04</td><td>1.37e+04</td><td><b><i>5.60e+02</i></b></td><td>9.22e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.69e+04</td><td>4.91e+03</td><td><b><i>1.03e+03</i></b></td><td>2.01e+03</td><td>7.57e+03</td><td>7.57e+03</td><td>7.57e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.59e+03</td><td>2.17e+03</td><td>7.47e+02</td><td><b><i>5.12e+02</i></b></td><td>8.21e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle10","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle10.cpp","code":"// FPBench triangle10\\ntemplate <class T>\\ninline T triangle10(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle10(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle10(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/10000000000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/10000000000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/10000000000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle10_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle10_variable_count = 3;","function_name":"triangle10","graph_name_base":"triangle10","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.04e+03</td><td>1.76e+04</td><td>1.33e+04</td><td><b><i>5.59e+02</i></b></td><td>9.19e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.61e+04</td><td>4.94e+03</td><td><b><i>1.03e+03</i></b></td><td>1.97e+03</td><td>7.50e+03</td><td>7.50e+03</td><td>7.50e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.94e+03</td><td>2.67e+03</td><td>9.23e+02</td><td><b><i>6.30e+02</i></b></td><td>1.01e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.3.7","expr":"(exp(X0) - 2.0) + exp(-X0)","num_variable":"1","file_name":"NMSE_problem_3_3_7.cpp","code":"// FPBench NMSE problem 3.3.7\\ntemplate <class T>\\ninline T NMSE_problem_3_3_7(const std::vector<T> &value_array)\\n{\\n\\treturn (exp(value_array[0]) - 2.0) + exp(-value_array[0]);\\n}\\nstd::string print_NMSE_problem_3_3_7(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (2)) + exp(-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_problem_3_3_7(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_3_7_range = {std::uniform_real_distribution<double>(-700, 700)};\\nconst int NMSE_problem_3_3_7_variable_count = 1;","function_name":"NMSE_problem_3_3_7","graph_name_base":"NMSE problem 3.3.7","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.47e+02</td><td>5.80e+03</td><td>2.88e+03</td><td><b><i>6.01e+02</i></b></td><td>7.56e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.59e+02</td><td>2.66e+03</td><td><b><i>3.63e+02</i></b></td><td>3.69e+02</td><td>4.08e+02</td><td>1.21e+03</td><td>1.21e+03</td><td>1.21e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.40e+02</td><td>6.74e+02</td><td><b><i>4.00e+02</i></b></td><td>4.66e+02</td><td>5.46e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench sineOrder3","expr":"(0.954929658551372 * X0) - (0.12900613773279798 * ((X0 * X0) * X0))","num_variable":"1","file_name":"sineOrder3.cpp","code":"// FPBench sineOrder3\\ntemplate <class T>\\ninline T sineOrder3(const std::vector<T> &value_array)\\n{\\n\\treturn (0.954929658551372 * value_array[0]) - (0.12900613773279798 * ((value_array[0] * value_array[0]) * value_array[0]));\\n}\\nstd::string print_sineOrder3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((238732414637843/250000000000000) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - ((6450306886639899/50000000000000000) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_sineOrder3(const std::vector<double> &v)\\n{\\n    if (-2.0 >= v[0])\\n        return false;\\n    if (v[0] >= 2.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sineOrder3_range = {std::uniform_real_distribution<double>(-2.0, 2.0)};\\nconst int sineOrder3_variable_count = 1;","function_name":"sineOrder3","graph_name_base":"sineOrder3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>7.20e+02</td><td>5.56e+03</td><td>3.53e+03</td><td><b><i>1.28e+02</i></b></td><td>1.90e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.80e+02</td><td>8.33e+03</td><td>3.54e+02</td><td><b><i>1.94e+02</i></b></td><td>2.66e+02</td><td>1.87e+03</td><td>1.85e+03</td><td>1.85e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.28e+02</td><td>5.72e+02</td><td>1.64e+02</td><td><b><i>1.43e+02</i></b></td><td>1.98e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench Rump\'s example revisited for floating point","expr":"((((333.75 - (X0 * X0)) * (((X1 * X1) * (X1 * X1)) * (X1 * X1))) + ((X0 * X0) * ((((11.0 * (X0 * X0)) * (X1 * X1)) - (121.0 * ((X1 * X1) * (X1 * X1)))) - 2.0))) + (5.5 * (((X1 * X1) * (X1 * X1)) * ((X1 * X1) * (X1 * X1))))) + (X0 / (2.0 * X1))","num_variable":"2","file_name":"Rump_s_example_revisited_for_floating_point.cpp","code":"// FPBench Rump\'s example revisited for floating point\\ntemplate <class T>\\ninline T Rump_s_example_revisited_for_floating_point(const std::vector<T> &value_array)\\n{\\n\\treturn ((((333.75 - (value_array[0] * value_array[0])) * (((value_array[1] * value_array[1]) * (value_array[1] * value_array[1])) * (value_array[1] * value_array[1]))) + ((value_array[0] * value_array[0]) * ((((11.0 * (value_array[0] * value_array[0])) * (value_array[1] * value_array[1])) - (121.0 * ((value_array[1] * value_array[1]) * (value_array[1] * value_array[1])))) - 2.0))) + (5.5 * (((value_array[1] * value_array[1]) * (value_array[1] * value_array[1])) * ((value_array[1] * value_array[1]) * (value_array[1] * value_array[1]))))) + (value_array[0] / (2.0 * value_array[1]));\\n}\\nstd::string print_Rump_s_example_revisited_for_floating_point(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((((1335/4) - (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))) + ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * (((((11) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - ((121) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")))) - (2)))) + ((11/2) * (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))))) + (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / ((2) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_Rump_s_example_revisited_for_floating_point(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> Rump_s_example_revisited_for_floating_point_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int Rump_s_example_revisited_for_floating_point_variable_count = 2;","function_name":"Rump_s_example_revisited_for_floating_point","graph_name_base":"Rump\'s example revisited for floating point","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.96e+03</td><td>3.72e+04</td><td>3.45e+04</td><td><b><i>8.84e+02</i></b></td><td>1.51e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.72e+03</td><td>3.69e+04</td><td>8.66e+03</td><td><b><i>1.99e+03</i></b></td><td>3.55e+03</td><td>1.26e+04</td><td>1.26e+04</td><td>1.26e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.35e+03</td><td>4.53e+03</td><td>1.33e+03</td><td><b><i>1.12e+03</i></b></td><td>1.52e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench floudas2","expr":"-X0 - X1","num_variable":"2","file_name":"floudas2.cpp","code":"// FPBench floudas2\\ntemplate <class T>\\ninline T floudas2(const std::vector<T> &value_array)\\n{\\n\\treturn -value_array[0] - value_array[1];\\n}\\nstd::string print_floudas2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\";\\n}\\nbool check_input_floudas2(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 3.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 4.0)\\n        return false;\\n    if (((((2 * ((v[0] * v[0]) * (v[0] * v[0]))) - ((8 * (v[0] * v[0])) * v[0])) + ((8 * v[0]) * v[0])) - v[1]) < 0)\\n        return false;\\n    if (((((((4 * ((v[0] * v[0]) * (v[0] * v[0]))) - ((32 * (v[0] * v[0])) * v[0])) + ((88 * v[0]) * v[0])) - (96 * v[0])) + 36) - v[1]) < 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> floudas2_range = {std::uniform_real_distribution<double>(0.0, 3.0), std::uniform_real_distribution<double>(0.0, 4.0)};\\nconst int floudas2_variable_count = 2;","function_name":"floudas2","graph_name_base":"floudas2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.17e+02</td><td>8.49e+02</td><td>5.11e+02</td><td><b><i>2.15e-01</i></b></td><td>3.81e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.02e+01</td><td>4.20e+02</td><td>1.83e+01</td><td><b><i>3.91e+00</i></b></td><td>3.98e+00</td><td>4.10e+02</td><td>3.32e+02</td><td>3.33e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.02e+02</td><td>1.21e+02</td><td>3.04e+01</td><td><b><i>1.03e+01</i></b></td><td>1.55e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench predatorPrey","expr":"(((4.0) * X0) * X0) / (1.0 + ((X0 / (1.11)) * (X0 / (1.11))))","num_variable":"1","file_name":"predatorPrey.cpp","code":"// FPBench predatorPrey\\ntemplate <class T>\\ninline T predatorPrey(const std::vector<T> &value_array)\\n{\\n\\treturn (((4.0) * value_array[0]) * value_array[0]) / (1.0 + ((value_array[0] / (1.11)) * (value_array[0] / (1.11))));\\n}\\nstd::string print_predatorPrey(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((((4)) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / ((1) + ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / ((111/100))) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / ((111/100)))))\\";\\n}\\nbool check_input_predatorPrey(const std::vector<double> &v)\\n{\\n    if (0.1 > v[0])\\n        return false;\\n    if (v[0] > 0.3)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> predatorPrey_range = {std::uniform_real_distribution<double>(0.1, 0.3)};\\nconst int predatorPrey_variable_count = 1;","function_name":"predatorPrey","graph_name_base":"predatorPrey","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.05e+03</td><td>6.45e+03</td><td>7.25e+03</td><td><b><i>1.92e+02</i></b></td><td>2.91e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.86e+02</td><td>9.10e+03</td><td>1.04e+03</td><td><b><i>2.43e+02</i></b></td><td>5.16e+02</td><td>2.76e+03</td><td>2.76e+03</td><td>2.76e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.70e+02</td><td>9.16e+02</td><td>3.29e+02</td><td><b><i>2.52e+02</i></b></td><td>3.65e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench Rump\'s example, from C program","expr":"(((333.75 * (((X1 * X1) * (X1 * X1)) * (X1 * X1))) + ((X0 * X0) * (((((11.0 * (X0 * X0)) * (X1 * X1)) - (((X1 * X1) * (X1 * X1)) * (X1 * X1))) - (121.0 * ((X1 * X1) * (X1 * X1)))) - 2.0))) + (5.5 * (((X1 * X1) * (X1 * X1)) * ((X1 * X1) * (X1 * X1))))) + (X0 / (2.0 * X1))","num_variable":"2","file_name":"Rump_s_example_from_C_program.cpp","code":"// FPBench Rump\'s example, from C program\\ntemplate <class T>\\ninline T Rump_s_example_from_C_program(const std::vector<T> &value_array)\\n{\\n\\treturn (((333.75 * (((value_array[1] * value_array[1]) * (value_array[1] * value_array[1])) * (value_array[1] * value_array[1]))) + ((value_array[0] * value_array[0]) * (((((11.0 * (value_array[0] * value_array[0])) * (value_array[1] * value_array[1])) - (((value_array[1] * value_array[1]) * (value_array[1] * value_array[1])) * (value_array[1] * value_array[1]))) - (121.0 * ((value_array[1] * value_array[1]) * (value_array[1] * value_array[1])))) - 2.0))) + (5.5 * (((value_array[1] * value_array[1]) * (value_array[1] * value_array[1])) * ((value_array[1] * value_array[1]) * (value_array[1] * value_array[1]))))) + (value_array[0] / (2.0 * value_array[1]));\\n}\\nstd::string print_Rump_s_example_from_C_program(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((((1335/4) * (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))) + ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * ((((((11) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))) - ((121) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")))) - (2)))) + ((11/2) * (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))))) + (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / ((2) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_Rump_s_example_from_C_program(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> Rump_s_example_from_C_program_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int Rump_s_example_from_C_program_variable_count = 2;","function_name":"Rump_s_example_from_C_program","graph_name_base":"Rump\'s example, from C program","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>5.55e+03</td><td>3.83e+04</td><td>3.81e+04</td><td><b><i>1.03e+03</i></b></td><td>1.73e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.06e+03</td><td>3.97e+04</td><td>9.19e+03</td><td><b><i>2.15e+03</i></b></td><td>4.07e+03</td><td>1.36e+04</td><td>1.35e+04</td><td>1.35e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.65e+03</td><td>4.90e+03</td><td>1.44e+03</td><td><b><i>1.23e+03</i></b></td><td>1.63e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle1","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle1.cpp","code":"// FPBench triangle1\\ntemplate <class T>\\ninline T triangle1(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle1(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/10))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/10))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/10))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle1_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle1_variable_count = 3;","function_name":"triangle1","graph_name_base":"triangle1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.67e+04</td><td>1.36e+04</td><td><b><i>5.60e+02</i></b></td><td>9.20e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.41e+03</td><td>2.69e+04</td><td>5.04e+03</td><td><b><i>1.03e+03</i></b></td><td>1.97e+03</td><td>7.56e+03</td><td>7.56e+03</td><td>7.57e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.63e+03</td><td>2.22e+03</td><td>7.65e+02</td><td><b><i>5.24e+02</i></b></td><td>8.39e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 9","expr":"exp((sqrt((exp(cos((X0) / (X3)))) / (exp(cos(sqrt(X5)))))) / (sqrt((cos(cos(cos(X2)))) / (sqrt(sin(cos(X1)))))))","num_variable":"6","file_name":"extra_function9.cpp","code":"// Composite expression 9\\ntemplate <class T>\\ninline T extra_function9(const std::vector<T> &value_array)\\n{\\n    return exp((sqrt((exp(cos((value_array[0]) / (value_array[3])))) / (exp(cos(sqrt(value_array[5])))))) / (sqrt((cos(cos(cos(value_array[2])))) / (sqrt(sin(cos(value_array[1])))))));\\n}\\nstd::string print_extra_function9(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"Exp\\" + \\"(\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"(\\" + \\"Exp\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"Exp\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function9(const std::vector<double> &value_array)\\n{\\n    if (value_array[3] == 0)\\n        return false;\\n    if (value_array[5] < 0)\\n        return false;\\n    if (exp(cos(sqrt(value_array[5]))) == 0)\\n        return false;\\n    if ((exp(cos((value_array[0]) / (value_array[3])))) / (exp(cos(sqrt(value_array[5])))) < 0)\\n        return false;\\n    if (sin(cos(value_array[1])) < 0)\\n        return false;\\n    if (sqrt(sin(cos(value_array[1]))) == 0)\\n        return false;\\n    if ((cos(cos(cos(value_array[2])))) / (sqrt(sin(cos(value_array[1])))) < 0)\\n        return false;\\n    if (sqrt((cos(cos(cos(value_array[2])))) / (sqrt(sin(cos(value_array[1]))))) == 0)\\n        return false;\\n    if ((sqrt((exp(cos((value_array[0]) / (value_array[3])))) / (exp(cos(sqrt(value_array[5])))))) / (sqrt((cos(cos(cos(value_array[2])))) / (sqrt(sin(cos(value_array[1])))))) < -700)\\n        return false;\\n    if ((sqrt((exp(cos((value_array[0]) / (value_array[3])))) / (exp(cos(sqrt(value_array[5])))))) / (sqrt((cos(cos(cos(value_array[2])))) / (sqrt(sin(cos(value_array[1])))))) > 700)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function9_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(0, RAND_MAX)};\\nconst int extra_function9_variable_count = 6;","function_name":"extra_function9","graph_name_base":"RANDOM EXPRESSION 9","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.78e+03</td><td>4.53e+04</td><td>6.95e+03</td><td><b><i>4.30e+03</i></b></td><td>4.40e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td><b><i>4.11e+03</i></b></td><td>5.89e+04</td><td>4.25e+03</td><td>4.29e+03</td><td>4.50e+03</td><td>2.40e+04</td><td>2.39e+04</td><td>2.38e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.81e+03</td><td>7.19e+03</td><td><b><i>3.55e+03</i></b></td><td>3.57e+03</td><td>3.66e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 8","expr":"exp((sin(X5) - cos(X0 + cos(X3))) / (X4))","num_variable":"6","file_name":"extra_function8.cpp","code":"// Composite expression 8\\ntemplate <class T>\\ninline T extra_function8(const std::vector<T> &value_array)\\n{\\n    return exp((sin(value_array[5]) - cos(value_array[0] + cos(value_array[3]))) / (value_array[4]));\\n}\\nstd::string print_extra_function8(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"Exp\\" + \\"(\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"-\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"+\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function8(const std::vector<double> &value_array)\\n{\\n    if (value_array[4] == 0)\\n        return false;\\n    if ((sin(value_array[5]) - cos(value_array[0] + cos(value_array[3]))) / (value_array[4]) < -700)\\n        return false;\\n    if ((sin(value_array[5]) - cos(value_array[0] + cos(value_array[3]))) / (value_array[4]) > 700)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function8_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int extra_function8_variable_count = 6;","function_name":"extra_function8","graph_name_base":"RANDOM EXPRESSION 8","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.63e+03</td><td>1.81e+04</td><td>3.87e+03</td><td><b><i>1.48e+03</i></b></td><td>1.57e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.49e+03</td><td>3.29e+04</td><td>1.62e+03</td><td><b><i>1.36e+03</i></b></td><td>1.49e+03</td><td>1.10e+04</td><td>1.10e+04</td><td>1.09e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.27e+03</td><td>2.96e+03</td><td><b><i>1.18e+03</i></b></td><td>1.19e+03</td><td>1.27e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench instantaneousCurrent","expr":"(sqrt((((X4 * (X1)) / (((X1) * (X1)) + ((((2.0 * (3.14159265359)) * X2) * X3) * (((2.0 * (3.14159265359)) * X2) * X3)))) * ((X4 * (X1)) / (((X1) * (X1)) + ((((2.0 * (3.14159265359)) * X2) * X3) * (((2.0 * (3.14159265359)) * X2) * X3))))) + ((-(X4 * (((2.0 * (3.14159265359)) * X2) * X3)) / (((X1) * (X1)) + ((((2.0 * (3.14159265359)) * X2) * X3) * (((2.0 * (3.14159265359)) * X2) * X3)))) * (-(X4 * (((2.0 * (3.14159265359)) * X2) * X3)) / (((X1) * (X1)) + ((((2.0 * (3.14159265359)) * X2) * X3) * (((2.0 * (3.14159265359)) * X2) * X3))))))) * cos((((2.0 * (3.14159265359)) * X2) * X0) + (atan((-(X4 * (((2.0 * (3.14159265359)) * X2) * X3)) / (((X1) * (X1)) + ((((2.0 * (3.14159265359)) * X2) * X3) * (((2.0 * (3.14159265359)) * X2) * X3)))) / ((X4 * (X1)) / (((X1) * (X1)) + ((((2.0 * (3.14159265359)) * X2) * X3) * (((2.0 * (3.14159265359)) * X2) * X3)))))))","num_variable":"5","file_name":"instantaneousCurrent.cpp","code":"// FPBench instantaneousCurrent\\ntemplate <class T>\\ninline T instantaneousCurrent(const std::vector<T> &value_array)\\n{\\n\\treturn (sqrt((((value_array[4] * (value_array[1])) / (((value_array[1]) * (value_array[1])) + ((((2.0 * (3.14159265359)) * value_array[2]) * value_array[3]) * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3])))) * ((value_array[4] * (value_array[1])) / (((value_array[1]) * (value_array[1])) + ((((2.0 * (3.14159265359)) * value_array[2]) * value_array[3]) * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3]))))) + ((-(value_array[4] * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3])) / (((value_array[1]) * (value_array[1])) + ((((2.0 * (3.14159265359)) * value_array[2]) * value_array[3]) * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3])))) * (-(value_array[4] * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3])) / (((value_array[1]) * (value_array[1])) + ((((2.0 * (3.14159265359)) * value_array[2]) * value_array[3]) * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3]))))))) * cos((((2.0 * (3.14159265359)) * value_array[2]) * value_array[0]) + (atan((-(value_array[4] * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3])) / (((value_array[1]) * (value_array[1])) + ((((2.0 * (3.14159265359)) * value_array[2]) * value_array[3]) * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3])))) / ((value_array[4] * (value_array[1])) / (((value_array[1]) * (value_array[1])) + ((((2.0 * (3.14159265359)) * value_array[2]) * value_array[3]) * (((2.0 * (3.14159265359)) * value_array[2]) * value_array[3])))))));\\n}\\nstd::string print_instantaneousCurrent(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(sqrt((((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) / (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) + (((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")))) * ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) / (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) + (((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\"))))) + ((-(\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) / (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) + (((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")))) * (-(\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) / (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) + (((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\"))))))) * cos(((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (atan((-(\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) / (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) + (((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")))) / ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) / (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) + (((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * ((((2) * ((314159265359/100000000000))) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")))))))\\";\\n}\\nbool check_input_instantaneousCurrent(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 300.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 50.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 100.0)\\n        return false;\\n    if (0.001 > v[3])\\n        return false;\\n    if (v[3] > 0.004)\\n        return false;\\n    if (1.0 > v[4])\\n        return false;\\n    if (v[4] > 12.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> instantaneousCurrent_range = {std::uniform_real_distribution<double>(0.0, 300.0), std::uniform_real_distribution<double>(1.0, 50.0), std::uniform_real_distribution<double>(1.0, 100.0), std::uniform_real_distribution<double>(0.001, 0.004), std::uniform_real_distribution<double>(1.0, 12.0)};\\nconst int instantaneousCurrent_variable_count = 5;","function_name":"instantaneousCurrent","graph_name_base":"instantaneousCurrent","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.14e+04</td><td>9.21e+04</td><td>7.28e+04</td><td><b><i>2.62e+03</i></b></td><td>3.69e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.06e+03</td><td>9.78e+04</td><td>2.18e+04</td><td><b><i>4.65e+03</i></b></td><td>7.93e+03</td><td>2.74e+04</td><td>2.74e+04</td><td>2.74e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.57e+03</td><td>1.07e+04</td><td>3.65e+03</td><td><b><i>3.11e+03</i></b></td><td>4.18e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench logexp","expr":"log(1.0 + exp(X0))","num_variable":"1","file_name":"logexp.cpp","code":"// FPBench logexp\\ntemplate <class T>\\ninline T logexp(const std::vector<T> &value_array)\\n{\\n\\treturn log(1.0 + exp(value_array[0]));\\n}\\nstd::string print_logexp(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"log((1) + exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_logexp(const std::vector<double> &v)\\n{\\n    if (-8.0 > v[0])\\n        return false;\\n    if (v[0] > 8.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> logexp_range = {std::uniform_real_distribution<double>(-8.0, 8.0)};\\nconst int logexp_variable_count = 1;","function_name":"logexp","graph_name_base":"logexp","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>7.58e+02</td><td>3.48e+03</td><td>1.36e+03</td><td><b><i>7.01e+02</i></b></td><td>7.60e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.26e+02</td><td>3.46e+03</td><td><b><i>4.23e+02</i></b></td><td>4.41e+02</td><td>4.47e+02</td><td>7.03e+02</td><td>7.02e+02</td><td>7.02e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.55e+02</td><td>5.74e+02</td><td><b><i>4.75e+02</i></b></td><td>5.44e+02</td><td>5.73e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench floudas3","expr":"((-12.0 * X0) - (7.0 * X1)) + (X1 * X1)","num_variable":"2","file_name":"floudas3.cpp","code":"// FPBench floudas3\\ntemplate <class T>\\ninline T floudas3(const std::vector<T> &value_array)\\n{\\n\\treturn ((-12.0 * value_array[0]) - (7.0 * value_array[1])) + (value_array[1] * value_array[1]);\\n}\\nstd::string print_floudas3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((-(12) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - ((7) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")\\";\\n}\\nbool check_input_floudas3(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 2.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 3.0)\\n        return false;\\n    if (((-2 * ((v[0] * v[0]) * (v[0] * v[0]))) + 2) < v[1])\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> floudas3_range = {std::uniform_real_distribution<double>(0.0, 2.0), std::uniform_real_distribution<double>(0.0, 3.0)};\\nconst int floudas3_variable_count = 2;","function_name":"floudas3","graph_name_base":"floudas3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.98e+02</td><td>5.61e+03</td><td>2.80e+03</td><td><b><i>1.25e+02</i></b></td><td>1.83e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.68e+02</td><td>6.04e+03</td><td>7.23e+02</td><td><b><i>1.36e+02</i></b></td><td>1.73e+02</td><td>1.65e+03</td><td>1.65e+03</td><td>1.65e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.57e+02</td><td>6.38e+02</td><td>1.61e+02</td><td><b><i>1.57e+02</i></b></td><td>1.85e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 9","expr":"(X0 - X3 - (X2) * (X5) - X7 + X1) * (X3) + (((((X4) * (X1)) / (X7 + X6)) * ((X6) / (X5) - (X1) * (X8))) * (X6)) * (((X2 + X7) / ((X4) / (X0)) + ((X3) * (X8)) / (X4 + X7)) / (((X6 - X0) / (X2 + X5)) / ((X3) / (X1) + (X7) * (X1)))) - X5 - ((X0) / (X3)) * (X2 + X8) + X2 + ((X8) / (X5 - X4) - (X6) / (X2) - X0 - X8) / ((X0) / (X4)) + X8","num_variable":"9","file_name":"expr9.cpp","code":"// Arithmetic expression 9\\ntemplate <class T>\\ninline T expr9(const std::vector<T> &value_array)\\n{\\n    return (value_array[0] - value_array[3] - (value_array[2]) * (value_array[5]) - value_array[7] + value_array[1]) * (value_array[3]) + (((((value_array[4]) * (value_array[1])) / (value_array[7] + value_array[6])) * ((value_array[6]) / (value_array[5]) - (value_array[1]) * (value_array[8]))) * (value_array[6])) * (((value_array[2] + value_array[7]) / ((value_array[4]) / (value_array[0])) + ((value_array[3]) * (value_array[8])) / (value_array[4] + value_array[7])) / (((value_array[6] - value_array[0]) / (value_array[2] + value_array[5])) / ((value_array[3]) / (value_array[1]) + (value_array[7]) * (value_array[1])))) - value_array[5] - ((value_array[0]) / (value_array[3])) * (value_array[2] + value_array[8]) + value_array[2] + ((value_array[8]) / (value_array[5] - value_array[4]) - (value_array[6]) / (value_array[2]) - value_array[0] - value_array[8]) / ((value_array[0]) / (value_array[4])) + value_array[8];\\n}\\nstd::string print_expr9(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"(\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[3]) + \\"-\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"-\\" + rational_to_string(value_array[7]) + \\"+\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"+\\" + \\"(\\" + \\"(\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[7]) + \\"+\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"-\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[8]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[2]) + \\"+\\" + rational_to_string(value_array[7]) + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\")\\" + \\"+\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[8]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[4]) + \\"+\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"-\\" + rational_to_string(value_array[0]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[2]) + \\"+\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"+\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"-\\" + rational_to_string(value_array[5]) + \\"-\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[2]) + \\"+\\" + rational_to_string(value_array[8]) + \\")\\" + \\"+\\" + rational_to_string(value_array[2]) + \\"+\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[8]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[5]) + \\"-\\" + rational_to_string(value_array[4]) + \\")\\" + \\"-\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\"-\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[8]) + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\")\\" + \\"+\\" + rational_to_string(value_array[8]);\\n}\\nbool check_input_expr9(const std::vector<double> &value_array)\\n{\\n    if (value_array[7] + value_array[6] == 0)\\n        return false;\\n    if (value_array[5] == 0)\\n        return false;\\n    if (value_array[0] == 0)\\n        return false;\\n    if ((value_array[4]) / (value_array[0]) == 0)\\n        return false;\\n    if (value_array[4] + value_array[7] == 0)\\n        return false;\\n    if (value_array[2] + value_array[5] == 0)\\n        return false;\\n    if (value_array[1] == 0)\\n        return false;\\n    if ((value_array[3]) / (value_array[1]) + (value_array[7]) * (value_array[1]) == 0)\\n        return false;\\n    if (((value_array[6] - value_array[0]) / (value_array[2] + value_array[5])) / ((value_array[3]) / (value_array[1]) + (value_array[7]) * (value_array[1])) == 0)\\n        return false;\\n    if (value_array[3] == 0)\\n        return false;\\n    if (value_array[5] - value_array[4] == 0)\\n        return false;\\n    if (value_array[2] == 0)\\n        return false;\\n    if (value_array[4] == 0)\\n        return false;\\n    if ((value_array[0]) / (value_array[4]) == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr9_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr9_variable_count = 9;","function_name":"expr9","graph_name_base":"ARITHMETIC EXPRESSION 9","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>7.28e+03</td><td>5.06e+04</td><td>4.68e+04</td><td><b><i>1.45e+03</i></b></td><td>2.33e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.31e+03</td><td>4.54e+04</td><td>1.35e+04</td><td><b><i>2.83e+03</i></b></td><td>5.05e+03</td><td>1.65e+04</td><td>1.65e+04</td><td>1.65e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.15e+03</td><td>5.58e+03</td><td>1.89e+03</td><td><b><i>1.33e+03</i></b></td><td>2.05e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench floudas1","expr":"(((((-25.0 * ((X0 - 2.0) * (X0 - 2.0))) - ((X1 - 2.0) * (X1 - 2.0))) - ((X2 - 1.0) * (X2 - 1.0))) - ((X3 - 4.0) * (X3 - 4.0))) - ((X4 - 1.0) * (X4 - 1.0))) - ((X5 - 4.0) * (X5 - 4.0))","num_variable":"6","file_name":"floudas1.cpp","code":"// FPBench floudas1\\ntemplate <class T>\\ninline T floudas1(const std::vector<T> &value_array)\\n{\\n\\treturn (((((-25.0 * ((value_array[0] - 2.0) * (value_array[0] - 2.0))) - ((value_array[1] - 2.0) * (value_array[1] - 2.0))) - ((value_array[2] - 1.0) * (value_array[2] - 1.0))) - ((value_array[3] - 4.0) * (value_array[3] - 4.0))) - ((value_array[4] - 1.0) * (value_array[4] - 1.0))) - ((value_array[5] - 4.0) * (value_array[5] - 4.0));\\n}\\nstd::string print_floudas1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((((-(25) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (2)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (2)))) - ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (2)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (2)))) - ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (1)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (1)))) - ((\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (4)) * (\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (4)))) - ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (1)) * (\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (1)))) - ((\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (4)) * (\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (4)))\\";\\n}\\nbool check_input_floudas1(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 6.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 6.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 5.0)\\n        return false;\\n    if (0.0 > v[3])\\n        return false;\\n    if (v[3] > 6.0)\\n        return false;\\n    if (0.0 > v[4])\\n        return false;\\n    if (v[4] > 6.0)\\n        return false;\\n    if (0.0 > v[5])\\n        return false;\\n    if (v[5] > 10.0)\\n        return false;\\n    if (((((v[2] - 3) * (v[2] - 3)) + v[3]) - 4) < 0)\\n        return false;\\n    if (((((v[4] - 3) * (v[4] - 3)) + v[5]) - 4) < 0)\\n        return false;\\n    if (((2 - v[0]) + (3 * v[1])) < 0)\\n        return false;\\n    if (((2 + v[0]) - v[1]) < 0)\\n        return false;\\n    if (((6 - v[0]) - v[1]) < 0)\\n        return false;\\n    if (((v[0] + v[1]) - 2) < 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> floudas1_range = {std::uniform_real_distribution<double>(0.0, 6.0), std::uniform_real_distribution<double>(0.0, 6.0), std::uniform_real_distribution<double>(1.0, 5.0), std::uniform_real_distribution<double>(0.0, 6.0), std::uniform_real_distribution<double>(0.0, 6.0), std::uniform_real_distribution<double>(0.0, 10.0)};\\nconst int floudas1_variable_count = 6;","function_name":"floudas1","graph_name_base":"floudas1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.47e+03</td><td>2.10e+04</td><td>1.93e+04</td><td><b><i>6.10e+02</i></b></td><td>9.94e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.74e+03</td><td>1.78e+04</td><td>6.03e+03</td><td><b><i>1.10e+03</i></b></td><td>2.23e+03</td><td>8.37e+03</td><td>8.35e+03</td><td>8.35e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.47e+03</td><td>3.29e+03</td><td>9.34e+02</td><td><b><i>5.93e+02</i></b></td><td>9.18e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.9","expr":"(1.0 / X0) - (1.0 / tan(X0))","num_variable":"1","file_name":"NMSE_example_3_9.cpp","code":"// FPBench NMSE example 3.9\\ntemplate <class T>\\ninline T NMSE_example_3_9(const std::vector<T> &value_array)\\n{\\n\\treturn (1.0 / value_array[0]) - (1.0 / tan(value_array[0]));\\n}\\nstd::string print_NMSE_example_3_9(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((1) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - ((1) / tan(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_NMSE_example_3_9(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_9_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_example_3_9_variable_count = 1;","function_name":"NMSE_example_3_9","graph_name_base":"NMSE example 3.9","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.01e+02</td><td>7.87e+03</td><td>2.64e+03</td><td><b><i>2.95e+02</i></b></td><td>3.88e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.64e+02</td><td>7.84e+03</td><td>4.76e+02</td><td><b><i>3.78e+02</i></b></td><td>4.62e+02</td><td>4.16e+03</td><td>4.16e+03</td><td>4.16e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.97e+02</td><td>1.06e+03</td><td>4.93e+02</td><td><b><i>3.82e+02</i></b></td><td>4.64e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE section 3.5","expr":"exp(X0 * X1) - 1.0","num_variable":"2","file_name":"NMSE_section_3_5.cpp","code":"// FPBench NMSE section 3.5\\ntemplate <class T>\\ninline T NMSE_section_3_5(const std::vector<T> &value_array)\\n{\\n\\treturn exp(value_array[0] * value_array[1]) - 1.0;\\n}\\nstd::string print_NMSE_section_3_5(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (1)\\";\\n}\\nbool check_input_NMSE_section_3_5(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_section_3_5_range = {std::uniform_real_distribution<double>(-25, 25), std::uniform_real_distribution<double>(-25, 25)};\\nconst int NMSE_section_3_5_variable_count = 2;","function_name":"NMSE_section_3_5","graph_name_base":"NMSE section 3.5","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.90e+02</td><td>4.34e+03</td><td>2.65e+03</td><td><b><i>5.97e+02</i></b></td><td>6.69e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.18e+02</td><td>2.58e+03</td><td>4.71e+02</td><td><b><i>3.92e+02</i></b></td><td>4.76e+02</td><td>9.89e+02</td><td>9.95e+02</td><td>1.00e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.77e+02</td><td>5.00e+02</td><td>3.27e+02</td><td><b><i>3.14e+02</i></b></td><td>3.25e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE section 3.11","expr":"exp(X0) / (exp(X0) - 1.0)","num_variable":"1","file_name":"NMSE_section_3_11.cpp","code":"// FPBench NMSE section 3.11\\ntemplate <class T>\\ninline T NMSE_section_3_11(const std::vector<T> &value_array)\\n{\\n\\treturn exp(value_array[0]) / (exp(value_array[0]) - 1.0);\\n}\\nstd::string print_NMSE_section_3_11(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / (exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (1))\\";\\n}\\nbool check_input_NMSE_section_3_11(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_section_3_11_range = {std::uniform_real_distribution<double>(-700, 700)};\\nconst int NMSE_section_3_11_variable_count = 1;","function_name":"NMSE_section_3_11","graph_name_base":"NMSE section 3.11","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td><b><i>6.27e+02</i></b></td><td>5.40e+03</td><td>2.54e+03</td><td>6.67e+02</td><td>7.24e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.62e+02</td><td>1.81e+03</td><td>7.41e+02</td><td><b><i>4.64e+02</i></b></td><td>5.41e+02</td><td>9.67e+02</td><td>8.92e+02</td><td>8.91e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.45e+02</td><td>6.87e+02</td><td><b><i>4.08e+02</i></b></td><td>4.25e+02</td><td>4.77e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle2","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle2.cpp","code":"// FPBench triangle2\\ntemplate <class T>\\ninline T triangle2(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle2(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/100))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/100))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/100))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle2_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle2_variable_count = 3;","function_name":"triangle2","graph_name_base":"triangle2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.04e+03</td><td>1.75e+04</td><td>1.34e+04</td><td><b><i>5.60e+02</i></b></td><td>9.19e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.69e+04</td><td>4.78e+03</td><td><b><i>1.04e+03</i></b></td><td>1.97e+03</td><td>7.52e+03</td><td>7.52e+03</td><td>7.52e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.90e+03</td><td>2.65e+03</td><td>9.02e+02</td><td><b><i>6.21e+02</i></b></td><td>9.93e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench delta","expr":"(((((((X0 * X3) * (((((-X0 + X1) + X2) - X3) + X4) + X5)) + ((X1 * X4) * (((((X0 - X1) + X2) + X3) - X4) + X5))) + ((X2 * X5) * (((((X0 + X1) - X2) + X3) + X4) - X5))) + ((-X1 * X2) * X3)) + ((-X0 * X2) * X4)) + ((-X0 * X1) * X5)) + ((-X3 * X4) * X5)","num_variable":"6","file_name":"delta.cpp","code":"// FPBench delta\\ntemplate <class T>\\ninline T delta(const std::vector<T> &value_array)\\n{\\n\\treturn (((((((value_array[0] * value_array[3]) * (((((-value_array[0] + value_array[1]) + value_array[2]) - value_array[3]) + value_array[4]) + value_array[5])) + ((value_array[1] * value_array[4]) * (((((value_array[0] - value_array[1]) + value_array[2]) + value_array[3]) - value_array[4]) + value_array[5]))) + ((value_array[2] * value_array[5]) * (((((value_array[0] + value_array[1]) - value_array[2]) + value_array[3]) + value_array[4]) - value_array[5]))) + ((-value_array[1] * value_array[2]) * value_array[3])) + ((-value_array[0] * value_array[2]) * value_array[4])) + ((-value_array[0] * value_array[1]) * value_array[5])) + ((-value_array[3] * value_array[4]) * value_array[5]);\\n}\\nstd::string print_delta(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * (((((-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") * (((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\"))) + ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\") * (((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\"))) + ((-\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) + ((-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\")) + ((-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) + ((-\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")\\";\\n}\\nbool check_input_delta(const std::vector<double> &v)\\n{\\n    if (4.0 > v[0])\\n        return false;\\n    if (v[0] > 6.3504)\\n        return false;\\n    if (4.0 > v[1])\\n        return false;\\n    if (v[1] > 6.3504)\\n        return false;\\n    if (4.0 > v[2])\\n        return false;\\n    if (v[2] > 6.3504)\\n        return false;\\n    if (4.0 > v[3])\\n        return false;\\n    if (v[3] > 6.3504)\\n        return false;\\n    if (4.0 > v[4])\\n        return false;\\n    if (v[4] > 6.3504)\\n        return false;\\n    if (4.0 > v[5])\\n        return false;\\n    if (v[5] > 6.3504)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> delta_range = {std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504)};\\nconst int delta_variable_count = 6;","function_name":"delta","graph_name_base":"delta","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>5.39e+03</td><td>3.10e+04</td><td>3.03e+04</td><td><b><i>8.86e+02</i></b></td><td>1.65e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.59e+03</td><td>3.90e+04</td><td>8.21e+03</td><td><b><i>1.70e+03</i></b></td><td>3.80e+03</td><td>1.20e+04</td><td>1.20e+04</td><td>1.20e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.08e+03</td><td>4.13e+03</td><td>1.12e+03</td><td><b><i>8.24e+02</i></b></td><td>1.40e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"subtraction","expr":"X0 - X1","num_variable":"2","file_name":"subtraction.cpp","code":"// subtraction\\ntemplate <class T>\\ninline T subtraction(const std::vector<T> &value_array)\\n{\\n    return value_array[0] - value_array[1];\\n}\\nstd::string print_subtraction(const std::vector<gmp::Rational> &value_array)\\n{\\n    return rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[1]);\\n}\\nbool check_input_subtraction(const std::vector<double> &value_array)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> subtraction_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int subtraction_variable_count = 2;","function_name":"subtraction","graph_name_base":"SUBTRACTION","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.12e+02</td><td>5.95e+02</td><td>3.67e+02</td><td><b><i>2.75e+01</i></b></td><td>3.13e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.41e+01</td><td>4.05e+02</td><td>1.85e+01</td><td><b><i>3.90e+00</i></b></td><td>3.90e+00</td><td>3.27e+02</td><td>3.27e+02</td><td>3.27e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>8.42e+01</td><td>1.15e+02</td><td>2.86e+01</td><td><b><i>9.94e+00</i></b></td><td>1.48e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.4.5","expr":"(X0 - sin(X0)) / (X0 - tan(X0))","num_variable":"1","file_name":"NMSE_problem_3_4_5.cpp","code":"// FPBench NMSE problem 3.4.5\\ntemplate <class T>\\ninline T NMSE_problem_3_4_5(const std::vector<T> &value_array)\\n{\\n\\treturn (value_array[0] - sin(value_array[0])) / (value_array[0] - tan(value_array[0]));\\n}\\nstd::string print_NMSE_problem_3_4_5(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - sin(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - tan(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_NMSE_problem_3_4_5(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_4_5_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_problem_3_4_5_variable_count = 1;","function_name":"NMSE_problem_3_4_5","graph_name_base":"NMSE problem 3.4.5","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>7.80e+02</td><td>1.24e+04</td><td>2.92e+03</td><td><b><i>5.11e+02</i></b></td><td>5.94e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.02e+02</td><td>2.05e+04</td><td>7.04e+02</td><td><b><i>5.37e+02</i></b></td><td>6.30e+02</td><td>7.25e+03</td><td>7.13e+03</td><td>7.15e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.00e+03</td><td>2.28e+03</td><td><b><i>6.07e+02</i></b></td><td>6.60e+02</td><td>7.58e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.4.4","expr":"sqrt((exp(2.0 * X0) - 1.0) / (exp(X0) - 1.0))","num_variable":"1","file_name":"NMSE_problem_3_4_4.cpp","code":"// FPBench NMSE problem 3.4.4\\ntemplate <class T>\\ninline T NMSE_problem_3_4_4(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((exp(2.0 * value_array[0]) - 1.0) / (exp(value_array[0]) - 1.0));\\n}\\nstd::string print_NMSE_problem_3_4_4(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((exp((2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (1)) / (exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (1)))\\";\\n}\\nbool check_input_NMSE_problem_3_4_4(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_4_4_range = {std::uniform_real_distribution<double>(-350, 350)};\\nconst int NMSE_problem_3_4_4_variable_count = 1;","function_name":"NMSE_problem_3_4_4","graph_name_base":"NMSE problem 3.4.4","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.40e+03</td><td>7.73e+03</td><td>4.49e+03</td><td><b><i>1.04e+03</i></b></td><td>1.21e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.06e+03</td><td>6.51e+03</td><td><b><i>5.42e+02</i></b></td><td>9.37e+02</td><td>9.43e+02</td><td>2.73e+03</td><td>2.71e+03</td><td>2.71e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.07e+03</td><td>1.11e+03</td><td><b><i>6.19e+02</i></b></td><td>8.17e+02</td><td>9.07e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench carbonGas","expr":"(((35000000.0) + (((0.401) * ((1000.0) / X0)) * ((1000.0) / X0))) * (X0 - ((1000.0) * (4.27e-05)))) - (((1.3806503e-23) * (1000.0)) * (300.0))","num_variable":"1","file_name":"carbonGas.cpp","code":"// FPBench carbonGas\\ntemplate <class T>\\ninline T carbonGas(const std::vector<T> &value_array)\\n{\\n\\treturn (((35000000.0) + (((0.401) * ((1000.0) / value_array[0])) * ((1000.0) / value_array[0]))) * (value_array[0] - ((1000.0) * (4.27e-05)))) - (((1.3806503e-23) * (1000.0)) * (300.0));\\n}\\nstd::string print_carbonGas(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((((35000000)) + ((((401/1000)) * (((1000)) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * (((1000)) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (((1000)) * (427/10000000)))) - (((13806503/1000000000000000000000000000000) * ((1000))) * ((300)))\\";\\n}\\nbool check_input_carbonGas(const std::vector<double> &v)\\n{\\n    if (0.1 > v[0])\\n        return false;\\n    if (v[0] > 0.5)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> carbonGas_range = {std::uniform_real_distribution<double>(0.1, 0.5)};\\nconst int carbonGas_variable_count = 1;","function_name":"carbonGas","graph_name_base":"carbonGas","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.17e+03</td><td>9.62e+03</td><td>8.16e+03</td><td><b><i>2.00e+02</i></b></td><td>3.69e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.87e+02</td><td>8.18e+03</td><td>1.35e+03</td><td><b><i>2.63e+02</i></b></td><td>6.68e+02</td><td>3.59e+03</td><td>3.60e+03</td><td>3.60e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>8.11e+02</td><td>1.04e+03</td><td>3.33e+02</td><td><b><i>2.43e+02</i></b></td><td>3.69e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle3","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle3.cpp","code":"// FPBench triangle3\\ntemplate <class T>\\ninline T triangle3(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle3(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/1000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/1000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/1000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle3_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle3_variable_count = 3;","function_name":"triangle3","graph_name_base":"triangle3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.64e+04</td><td>1.37e+04</td><td><b><i>5.60e+02</i></b></td><td>9.20e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.62e+04</td><td>4.92e+03</td><td><b><i>1.04e+03</i></b></td><td>1.97e+03</td><td>7.54e+03</td><td>7.55e+03</td><td>7.53e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.78e+03</td><td>2.45e+03</td><td>8.45e+02</td><td><b><i>5.78e+02</i></b></td><td>9.24e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench hartman6","expr":"-((((1.0 * (exp(-((((((10.0 * ((X0 - 0.1312) * (X0 - 0.1312))) + (3.0 * ((X1 - 0.1696) * (X1 - 0.1696)))) + (17.0 * ((X2 - 0.5569) * (X2 - 0.5569)))) + (3.5 * ((X3 - 0.0124) * (X3 - 0.0124)))) + (1.7 * ((X4 - 0.8283) * (X4 - 0.8283)))) + (8.0 * ((X5 - 0.5886) * (X5 - 0.5886))))))) + (1.2 * (exp(-((((((0.05 * ((X0 - 0.2329) * (X0 - 0.2329))) + (10.0 * ((X1 - 0.4135) * (X1 - 0.4135)))) + (17.0 * ((X2 - 0.8307) * (X2 - 0.8307)))) + (0.1 * ((X3 - 0.3736) * (X3 - 0.3736)))) + (8.0 * ((X4 - 0.1004) * (X4 - 0.1004)))) + (14.0 * ((X5 - 0.9991) * (X5 - 0.9991)))))))) + (3.0 * (exp(-((((((3.0 * ((X0 - 0.2348) * (X0 - 0.2348))) + (3.5 * ((X1 - 0.1451) * (X1 - 0.1451)))) + (1.7 * ((X2 - 0.3522) * (X2 - 0.3522)))) + (10.0 * ((X3 - 0.2883) * (X3 - 0.2883)))) + (17.0 * ((X4 - 0.3047) * (X4 - 0.3047)))) + (8.0 * ((X5 - 0.665) * (X5 - 0.665)))))))) + (3.2 * (exp(-((((((17.0 * ((X0 - 0.4047) * (X0 - 0.4047))) + (8.0 * ((X1 - 0.8828) * (X1 - 0.8828)))) + (0.05 * ((X2 - 0.8732) * (X2 - 0.8732)))) + (10.0 * ((X3 - 0.5743) * (X3 - 0.5743)))) + (0.1 * ((X4 - 0.1091) * (X4 - 0.1091)))) + (14.0 * ((X5 - 0.0381) * (X5 - 0.0381))))))))","num_variable":"6","file_name":"hartman6.cpp","code":"// FPBench hartman6\\ntemplate <class T>\\ninline T hartman6(const std::vector<T> &value_array)\\n{\\n\\treturn -((((1.0 * (exp(-((((((10.0 * ((value_array[0] - 0.1312) * (value_array[0] - 0.1312))) + (3.0 * ((value_array[1] - 0.1696) * (value_array[1] - 0.1696)))) + (17.0 * ((value_array[2] - 0.5569) * (value_array[2] - 0.5569)))) + (3.5 * ((value_array[3] - 0.0124) * (value_array[3] - 0.0124)))) + (1.7 * ((value_array[4] - 0.8283) * (value_array[4] - 0.8283)))) + (8.0 * ((value_array[5] - 0.5886) * (value_array[5] - 0.5886))))))) + (1.2 * (exp(-((((((0.05 * ((value_array[0] - 0.2329) * (value_array[0] - 0.2329))) + (10.0 * ((value_array[1] - 0.4135) * (value_array[1] - 0.4135)))) + (17.0 * ((value_array[2] - 0.8307) * (value_array[2] - 0.8307)))) + (0.1 * ((value_array[3] - 0.3736) * (value_array[3] - 0.3736)))) + (8.0 * ((value_array[4] - 0.1004) * (value_array[4] - 0.1004)))) + (14.0 * ((value_array[5] - 0.9991) * (value_array[5] - 0.9991)))))))) + (3.0 * (exp(-((((((3.0 * ((value_array[0] - 0.2348) * (value_array[0] - 0.2348))) + (3.5 * ((value_array[1] - 0.1451) * (value_array[1] - 0.1451)))) + (1.7 * ((value_array[2] - 0.3522) * (value_array[2] - 0.3522)))) + (10.0 * ((value_array[3] - 0.2883) * (value_array[3] - 0.2883)))) + (17.0 * ((value_array[4] - 0.3047) * (value_array[4] - 0.3047)))) + (8.0 * ((value_array[5] - 0.665) * (value_array[5] - 0.665)))))))) + (3.2 * (exp(-((((((17.0 * ((value_array[0] - 0.4047) * (value_array[0] - 0.4047))) + (8.0 * ((value_array[1] - 0.8828) * (value_array[1] - 0.8828)))) + (0.05 * ((value_array[2] - 0.8732) * (value_array[2] - 0.8732)))) + (10.0 * ((value_array[3] - 0.5743) * (value_array[3] - 0.5743)))) + (0.1 * ((value_array[4] - 0.1091) * (value_array[4] - 0.1091)))) + (14.0 * ((value_array[5] - 0.0381) * (value_array[5] - 0.0381))))))));\\n}\\nstd::string print_hartman6(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"-(((((1) * (exp(-(((((((10) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (82/625)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (82/625)))) + ((3) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (106/625)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (106/625))))) + ((17) * ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (5569/10000)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (5569/10000))))) + ((7/2) * ((\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (31/2500)) * (\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (31/2500))))) + ((17/10) * ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (8283/10000)) * (\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (8283/10000))))) + ((8) * ((\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (2943/5000)) * (\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (2943/5000)))))))) + ((6/5) * (exp(-(((((((1/20) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (2329/10000)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (2329/10000)))) + ((10) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (827/2000)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (827/2000))))) + ((17) * ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (8307/10000)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (8307/10000))))) + ((1/10) * ((\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (467/1250)) * (\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (467/1250))))) + ((8) * ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (251/2500)) * (\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (251/2500))))) + ((14) * ((\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (9991/10000)) * (\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (9991/10000))))))))) + ((3) * (exp(-(((((((3) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (587/2500)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (587/2500)))) + ((7/2) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (1451/10000)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (1451/10000))))) + ((17/10) * ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (1761/5000)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (1761/5000))))) + ((10) * ((\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (2883/10000)) * (\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (2883/10000))))) + ((17) * ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (3047/10000)) * (\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (3047/10000))))) + ((8) * ((\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (133/200)) * (\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (133/200))))))))) + ((16/5) * (exp(-(((((((17) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (4047/10000)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (4047/10000)))) + ((8) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (2207/2500)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (2207/2500))))) + ((1/20) * ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (2183/2500)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (2183/2500))))) + ((10) * ((\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (5743/10000)) * (\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - (5743/10000))))) + ((1/10) * ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (1091/10000)) * (\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" - (1091/10000))))) + ((14) * ((\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (381/10000)) * (\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" - (381/10000)))))))))\\";\\n}\\nbool check_input_hartman6(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 1.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 1.0)\\n        return false;\\n    if (0.0 > v[2])\\n        return false;\\n    if (v[2] > 1.0)\\n        return false;\\n    if (0.0 > v[3])\\n        return false;\\n    if (v[3] > 1.0)\\n        return false;\\n    if (0.0 > v[4])\\n        return false;\\n    if (v[4] > 1.0)\\n        return false;\\n    if (0.0 > v[5])\\n        return false;\\n    if (v[5] > 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> hartman6_range = {std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0)};\\nconst int hartman6_variable_count = 6;","function_name":"hartman6","graph_name_base":"hartman6","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.98e+04</td><td>1.32e+05</td><td>1.13e+05</td><td><b><i>5.74e+03</i></b></td><td>7.55e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.13e+04</td><td>1.02e+05</td><td>3.85e+04</td><td><b><i>7.77e+03</i></b></td><td>1.40e+04</td><td>6.20e+04</td><td>6.20e+04</td><td>6.20e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.31e+04</td><td>1.67e+04</td><td>5.62e+03</td><td><b><i>4.61e+03</i></b></td><td>6.52e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.2.1, negative","expr":"(-X1 - sqrt((X1 * X1) - (X0 * X2))) / X0","num_variable":"3","file_name":"NMSE_problem_3_2_1_negative.cpp","code":"// FPBench NMSE problem 3.2.1, negative\\ntemplate <class T>\\ninline T NMSE_problem_3_2_1_negative(const std::vector<T> &value_array)\\n{\\n\\treturn (-value_array[1] - sqrt((value_array[1] * value_array[1]) - (value_array[0] * value_array[2]))) / value_array[0];\\n}\\nstd::string print_NMSE_problem_3_2_1_negative(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(-\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - sqrt((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\";\\n}\\nbool check_input_NMSE_problem_3_2_1_negative(const std::vector<double> &v)\\n{\\n    if ((v[1] * v[1]) < (v[0] * v[2]))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_2_1_negative_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_problem_3_2_1_negative_variable_count = 3;","function_name":"NMSE_problem_3_2_1_negative","graph_name_base":"NMSE problem 3.2.1, negative","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>9.77e+02</td><td>6.46e+03</td><td>5.26e+03</td><td><b><i>2.43e+02</i></b></td><td>3.64e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.40e+02</td><td>8.03e+03</td><td>4.77e+02</td><td><b><i>3.33e+02</i></b></td><td>5.44e+02</td><td>1.86e+03</td><td>1.86e+03</td><td>1.86e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.31e+02</td><td>8.29e+02</td><td>3.48e+02</td><td><b><i>2.58e+02</i></b></td><td>3.57e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench jetEngine","expr":"X0 + (((((((((2.0 * X0) * (((((3.0 * X0) * X0) + (2.0 * X1)) - X0) / ((X0 * X0) + 1.0))) * ((((((3.0 * X0) * X0) + (2.0 * X1)) - X0) / ((X0 * X0) + 1.0)) - 3.0)) + ((X0 * X0) * ((4.0 * (((((3.0 * X0) * X0) + (2.0 * X1)) - X0) / ((X0 * X0) + 1.0))) - 6.0))) * ((X0 * X0) + 1.0)) + (((3.0 * X0) * X0) * (((((3.0 * X0) * X0) + (2.0 * X1)) - X0) / ((X0 * X0) + 1.0)))) + ((X0 * X0) * X0)) + X0) + (3.0 * (((((3.0 * X0) * X0) - (2.0 * X1)) - X0) / ((X0 * X0) + 1.0))))","num_variable":"2","file_name":"jetEngine.cpp","code":"// FPBench jetEngine\\ntemplate <class T>\\ninline T jetEngine(const std::vector<T> &value_array)\\n{\\n\\treturn value_array[0] + (((((((((2.0 * value_array[0]) * (((((3.0 * value_array[0]) * value_array[0]) + (2.0 * value_array[1])) - value_array[0]) / ((value_array[0] * value_array[0]) + 1.0))) * ((((((3.0 * value_array[0]) * value_array[0]) + (2.0 * value_array[1])) - value_array[0]) / ((value_array[0] * value_array[0]) + 1.0)) - 3.0)) + ((value_array[0] * value_array[0]) * ((4.0 * (((((3.0 * value_array[0]) * value_array[0]) + (2.0 * value_array[1])) - value_array[0]) / ((value_array[0] * value_array[0]) + 1.0))) - 6.0))) * ((value_array[0] * value_array[0]) + 1.0)) + (((3.0 * value_array[0]) * value_array[0]) * (((((3.0 * value_array[0]) * value_array[0]) + (2.0 * value_array[1])) - value_array[0]) / ((value_array[0] * value_array[0]) + 1.0)))) + ((value_array[0] * value_array[0]) * value_array[0])) + value_array[0]) + (3.0 * (((((3.0 * value_array[0]) * value_array[0]) - (2.0 * value_array[1])) - value_array[0]) / ((value_array[0] * value_array[0]) + 1.0))));\\n}\\nstd::string print_jetEngine(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + ((((((((((2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * ((((((3) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + ((2) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (1)))) * (((((((3) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + ((2) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (1))) - (3))) + ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * (((4) * ((((((3) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + ((2) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (1)))) - (6)))) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (1))) + ((((3) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * ((((((3) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + ((2) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (1))))) + ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + ((3) * ((((((3) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - ((2) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (1)))))\\";\\n}\\nbool check_input_jetEngine(const std::vector<double> &v)\\n{\\n    if (-5.0 > v[0])\\n        return false;\\n    if (v[0] > 5.0)\\n        return false;\\n    if (-20.0 > v[1])\\n        return false;\\n    if (v[1] > 5.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> jetEngine_range = {std::uniform_real_distribution<double>(-5.0, 5.0), std::uniform_real_distribution<double>(-20.0, 5.0)};\\nconst int jetEngine_variable_count = 2;","function_name":"jetEngine","graph_name_base":"jetEngine","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>9.69e+03</td><td>6.41e+04</td><td>5.36e+04</td><td><b><i>1.70e+03</i></b></td><td>3.05e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.30e+03</td><td>5.88e+04</td><td>1.91e+04</td><td><b><i>3.56e+03</i></b></td><td>6.80e+03</td><td>2.43e+04</td><td>2.43e+04</td><td>2.43e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.35e+03</td><td>8.56e+03</td><td>2.48e+03</td><td><b><i>2.05e+03</i></b></td><td>3.02e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.8","expr":"(((X0 + 1.0) * log(X0 + 1.0)) - (X0 * log(X0))) - 1.0","num_variable":"1","file_name":"NMSE_example_3_8.cpp","code":"// FPBench NMSE example 3.8\\ntemplate <class T>\\ninline T NMSE_example_3_8(const std::vector<T> &value_array)\\n{\\n\\treturn (((value_array[0] + 1.0) * log(value_array[0] + 1.0)) - (value_array[0] * log(value_array[0]))) - 1.0;\\n}\\nstd::string print_NMSE_example_3_8(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1)) * log(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1))) - (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * log(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))) - (1)\\";\\n}\\nbool check_input_NMSE_example_3_8(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_8_range = {std::uniform_real_distribution<double>(0, RAND_MAX)};\\nconst int NMSE_example_3_8_variable_count = 1;","function_name":"NMSE_example_3_8","graph_name_base":"NMSE example 3.8","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.71e+03</td><td>7.08e+03</td><td>5.13e+03</td><td><b><i>8.85e+02</i></b></td><td>1.04e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.21e+03</td><td>1.32e+04</td><td>1.25e+03</td><td><b><i>5.45e+02</i></b></td><td>7.53e+02</td><td>2.27e+03</td><td>2.27e+03</td><td>2.27e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>9.15e+02</td><td>1.09e+03</td><td><b><i>5.12e+02</i></b></td><td>5.58e+02</td><td>6.63e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 8","expr":"((X5) / ((X7) / (X0 - ((X2 + X1) * ((X1) * (X3))) * (X3 - X4)))) / (X6)","num_variable":"8","file_name":"expr8.cpp","code":"// Arithmetic expression 8\\ntemplate <class T>\\ninline T expr8(const std::vector<T> &value_array)\\n{\\n    return ((value_array[5]) / ((value_array[7]) / (value_array[0] - ((value_array[2] + value_array[1]) * ((value_array[1]) * (value_array[3]))) * (value_array[3] - value_array[4])))) / (value_array[6]);\\n}\\nstd::string print_expr8(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"(\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"-\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[2]) + \\"+\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\"-\\" + rational_to_string(value_array[4]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\";\\n}\\nbool check_input_expr8(const std::vector<double> &value_array)\\n{\\n    if (value_array[0] - ((value_array[2] + value_array[1]) * ((value_array[1]) * (value_array[3]))) * (value_array[3] - value_array[4]) == 0)\\n        return false;\\n    if ((value_array[7]) / (value_array[0] - ((value_array[2] + value_array[1]) * ((value_array[1]) * (value_array[3]))) * (value_array[3] - value_array[4])) == 0)\\n        return false;\\n    if (value_array[6] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr8_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr8_variable_count = 8;","function_name":"expr8","graph_name_base":"ARITHMETIC EXPRESSION 8","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.42e+03</td><td>9.90e+03</td><td>9.21e+03</td><td><b><i>2.86e+02</i></b></td><td>4.98e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.23e+02</td><td>9.34e+03</td><td>1.82e+03</td><td><b><i>5.61e+02</i></b></td><td>9.45e+02</td><td>3.17e+03</td><td>3.16e+03</td><td>3.19e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.90e+02</td><td>1.11e+03</td><td>3.64e+02</td><td><b><i>2.77e+02</i></b></td><td>4.45e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench Shoelace formula","expr":"0.5 * ((((X0 * X3) - (X1 * X2)) + ((X2 * X5) - (X3 * X4))) + ((X4 * X1) - (X5 * X0)))","num_variable":"6","file_name":"Shoelace_formula.cpp","code":"// FPBench Shoelace formula\\ntemplate <class T>\\ninline T Shoelace_formula(const std::vector<T> &value_array)\\n{\\n\\treturn 0.5 * ((((value_array[0] * value_array[3]) - (value_array[1] * value_array[2])) + ((value_array[2] * value_array[5]) - (value_array[3] * value_array[4]))) + ((value_array[4] * value_array[1]) - (value_array[5] * value_array[0])));\\n}\\nstd::string print_Shoelace_formula(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(1/2) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") - (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\") - (\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\"))) + ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")))\\";\\n}\\nbool check_input_Shoelace_formula(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> Shoelace_formula_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int Shoelace_formula_variable_count = 6;","function_name":"Shoelace_formula","graph_name_base":"Shoelace formula","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.76e+03</td><td>1.19e+04</td><td>1.16e+04</td><td><b><i>3.50e+02</i></b></td><td>5.26e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.05e+03</td><td>1.30e+04</td><td>2.27e+03</td><td><b><i>6.29e+02</i></b></td><td>1.02e+03</td><td>4.43e+03</td><td>4.43e+03</td><td>4.42e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.03e+03</td><td>1.36e+03</td><td>4.15e+02</td><td><b><i>3.15e+02</i></b></td><td>4.34e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle7","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle7.cpp","code":"// FPBench triangle7\\ntemplate <class T>\\ninline T triangle7(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle7(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle7(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/10000000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/10000000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/10000000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle7_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle7_variable_count = 3;","function_name":"triangle7","graph_name_base":"triangle7","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.63e+04</td><td>1.37e+04</td><td><b><i>5.61e+02</i></b></td><td>9.22e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.34e+03</td><td>2.42e+04</td><td>4.53e+03</td><td><b><i>1.03e+03</i></b></td><td>1.97e+03</td><td>7.55e+03</td><td>7.55e+03</td><td>7.55e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.77e+03</td><td>2.42e+03</td><td>8.34e+02</td><td><b><i>5.72e+02</i></b></td><td>9.14e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench doppler3","expr":"(-(331.4 + (0.6 * X2)) * X1) / (((331.4 + (0.6 * X2)) + X0) * ((331.4 + (0.6 * X2)) + X0))","num_variable":"3","file_name":"doppler3.cpp","code":"// FPBench doppler3\\ntemplate <class T>\\ninline T doppler3(const std::vector<T> &value_array)\\n{\\n\\treturn (-(331.4 + (0.6 * value_array[2])) * value_array[1]) / (((331.4 + (0.6 * value_array[2])) + value_array[0]) * ((331.4 + (0.6 * value_array[2])) + value_array[0]));\\n}\\nstd::string print_doppler3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(-((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") / ((((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * (((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_doppler3(const std::vector<double> &v)\\n{\\n    if (-30.0 > v[0])\\n        return false;\\n    if (v[0] > 120.0)\\n        return false;\\n    if (320.0 > v[1])\\n        return false;\\n    if (v[1] > 20300.0)\\n        return false;\\n    if (-50.0 > v[2])\\n        return false;\\n    if (v[2] > 30.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> doppler3_range = {std::uniform_real_distribution<double>(-30.0, 120.0), std::uniform_real_distribution<double>(320.0, 20300.0), std::uniform_real_distribution<double>(-50.0, 30.0)};\\nconst int doppler3_variable_count = 3;","function_name":"doppler3","graph_name_base":"doppler3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.67e+03</td><td>1.19e+04</td><td>1.16e+04</td><td><b><i>2.59e+02</i></b></td><td>4.40e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.93e+02</td><td>1.61e+04</td><td>1.83e+03</td><td><b><i>4.33e+02</i></b></td><td>7.74e+02</td><td>3.73e+03</td><td>3.72e+03</td><td>3.72e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>9.33e+02</td><td>1.30e+03</td><td>3.68e+02</td><td><b><i>2.77e+02</i></b></td><td>4.40e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench hypot","expr":"sqrt((X0 * X0) + (X1 * X1))","num_variable":"2","file_name":"hypot.cpp","code":"// FPBench hypot\\ntemplate <class T>\\ninline T hypot(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((value_array[0] * value_array[0]) + (value_array[1] * value_array[1]));\\n}\\nstd::string print_hypot(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_hypot(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 100.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 100.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> hypot_range = {std::uniform_real_distribution<double>(1.0, 100.0), std::uniform_real_distribution<double>(1.0, 100.0)};\\nconst int hypot_variable_count = 2;","function_name":"hypot","graph_name_base":"hypot","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.24e+02</td><td>5.15e+03</td><td>3.23e+03</td><td><b><i>1.62e+02</i></b></td><td>2.15e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.98e+02</td><td>4.13e+03</td><td><b><i>7.88e+01</i></b></td><td>1.53e+02</td><td>2.72e+02</td><td>1.09e+03</td><td>1.09e+03</td><td>1.09e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.70e+02</td><td>4.73e+02</td><td>2.15e+02</td><td><b><i>1.37e+02</i></b></td><td>1.85e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.4.1","expr":"(1.0 - cos(X0)) / (X0 * X0)","num_variable":"1","file_name":"NMSE_problem_3_4_1.cpp","code":"// FPBench NMSE problem 3.4.1\\ntemplate <class T>\\ninline T NMSE_problem_3_4_1(const std::vector<T> &value_array)\\n{\\n    return (1.0 - cos(value_array[0])) / (value_array[0] * value_array[0]);\\n}\\nstd::string print_NMSE_problem_3_4_1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((1) - cos(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_problem_3_4_1(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_4_1_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_problem_3_4_1_variable_count = 1;","function_name":"NMSE_problem_3_4_1","graph_name_base":"NMSE problem 3.4.1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>5.99e+02</td><td>7.90e+03</td><td>3.26e+03</td><td><b><i>2.77e+02</i></b></td><td>3.69e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.42e+02</td><td>1.26e+04</td><td>7.66e+02</td><td><b><i>3.71e+02</i></b></td><td>5.19e+02</td><td>5.07e+03</td><td>5.07e+03</td><td>5.03e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.70e+02</td><td>1.34e+03</td><td>4.58e+02</td><td><b><i>3.85e+02</i></b></td><td>4.39e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench doppler2","expr":"(-(331.4 + (0.6 * X2)) * X1) / (((331.4 + (0.6 * X2)) + X0) * ((331.4 + (0.6 * X2)) + X0))","num_variable":"3","file_name":"doppler2.cpp","code":"// FPBench doppler2\\ntemplate <class T>\\ninline T doppler2(const std::vector<T> &value_array)\\n{\\n\\treturn (-(331.4 + (0.6 * value_array[2])) * value_array[1]) / (((331.4 + (0.6 * value_array[2])) + value_array[0]) * ((331.4 + (0.6 * value_array[2])) + value_array[0]));\\n}\\nstd::string print_doppler2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(-((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") / ((((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * (((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_doppler2(const std::vector<double> &v)\\n{\\n    if (-125.0 > v[0])\\n        return false;\\n    if (v[0] > 125.0)\\n        return false;\\n    if (15.0 > v[1])\\n        return false;\\n    if (v[1] > 25000.0)\\n        return false;\\n    if (-40.0 > v[2])\\n        return false;\\n    if (v[2] > 60.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> doppler2_range = {std::uniform_real_distribution<double>(-125.0, 125.0), std::uniform_real_distribution<double>(15.0, 25000.0), std::uniform_real_distribution<double>(-40.0, 60.0)};\\nconst int doppler2_variable_count = 3;","function_name":"doppler2","graph_name_base":"doppler2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.67e+03</td><td>1.29e+04</td><td>1.22e+04</td><td><b><i>2.60e+02</i></b></td><td>4.41e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.82e+02</td><td>1.66e+04</td><td>1.56e+03</td><td><b><i>4.49e+02</i></b></td><td>4.81e+02</td><td>3.73e+03</td><td>3.72e+03</td><td>3.73e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.06e+03</td><td>1.45e+03</td><td>4.10e+02</td><td><b><i>3.12e+02</i></b></td><td>4.93e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench nonlin1","expr":"X0 / (X0 + 1.0)","num_variable":"1","file_name":"nonlin1.cpp","code":"// FPBench nonlin1\\ntemplate <class T>\\ninline T nonlin1(const std::vector<T> &value_array)\\n{\\n\\treturn value_array[0] / (value_array[0] + 1.0);\\n}\\nstd::string print_nonlin1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1))\\";\\n}\\nbool check_input_nonlin1(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 999.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> nonlin1_range = {std::uniform_real_distribution<double>(0.0, 999.0)};\\nconst int nonlin1_variable_count = 1;","function_name":"nonlin1","graph_name_base":"nonlin1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.06e+02</td><td>1.85e+03</td><td>1.57e+03</td><td><b><i>5.58e+01</i></b></td><td>7.74e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.46e+02</td><td>8.64e+02</td><td>3.49e+02</td><td><b><i>7.59e+01</i></b></td><td>1.25e+02</td><td>6.65e+02</td><td>6.64e+02</td><td>6.63e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.78e+02</td><td>2.43e+02</td><td>7.89e+01</td><td><b><i>5.55e+01</i></b></td><td>7.27e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle6","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle6.cpp","code":"// FPBench triangle6\\ntemplate <class T>\\ninline T triangle6(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle6(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle6(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/1000000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/1000000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/1000000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle6_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle6_variable_count = 3;","function_name":"triangle6","graph_name_base":"triangle6","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.06e+03</td><td>1.71e+04</td><td>1.36e+04</td><td><b><i>5.63e+02</i></b></td><td>9.24e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.69e+04</td><td>5.03e+03</td><td><b><i>1.04e+03</i></b></td><td>1.98e+03</td><td>7.55e+03</td><td>7.53e+03</td><td>7.54e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.76e+03</td><td>2.43e+03</td><td>8.38e+02</td><td><b><i>5.74e+02</i></b></td><td>9.14e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench hartman3","expr":"-((((1.0 * (exp(-(((3.0 * ((X0 - 0.3689) * (X0 - 0.3689))) + (10.0 * ((X1 - 0.117) * (X1 - 0.117)))) + (30.0 * ((X2 - 0.2673) * (X2 - 0.2673))))))) + (1.2 * (exp(-(((0.1 * ((X0 - 0.4699) * (X0 - 0.4699))) + (10.0 * ((X1 - 0.4387) * (X1 - 0.4387)))) + (35.0 * ((X2 - 0.747) * (X2 - 0.747)))))))) + (3.0 * (exp(-(((3.0 * ((X0 - 0.1091) * (X0 - 0.1091))) + (10.0 * ((X1 - 0.8732) * (X1 - 0.8732)))) + (30.0 * ((X2 - 0.5547) * (X2 - 0.5547)))))))) + (3.2 * (exp(-(((0.1 * ((X0 - 0.03815) * (X0 - 0.03815))) + (10.0 * ((X1 - 0.5743) * (X1 - 0.5743)))) + (35.0 * ((X2 - 0.8828) * (X2 - 0.8828))))))))","num_variable":"3","file_name":"hartman3.cpp","code":"// FPBench hartman3\\ntemplate <class T>\\ninline T hartman3(const std::vector<T> &value_array)\\n{\\n\\treturn -((((1.0 * (exp(-(((3.0 * ((value_array[0] - 0.3689) * (value_array[0] - 0.3689))) + (10.0 * ((value_array[1] - 0.117) * (value_array[1] - 0.117)))) + (30.0 * ((value_array[2] - 0.2673) * (value_array[2] - 0.2673))))))) + (1.2 * (exp(-(((0.1 * ((value_array[0] - 0.4699) * (value_array[0] - 0.4699))) + (10.0 * ((value_array[1] - 0.4387) * (value_array[1] - 0.4387)))) + (35.0 * ((value_array[2] - 0.747) * (value_array[2] - 0.747)))))))) + (3.0 * (exp(-(((3.0 * ((value_array[0] - 0.1091) * (value_array[0] - 0.1091))) + (10.0 * ((value_array[1] - 0.8732) * (value_array[1] - 0.8732)))) + (30.0 * ((value_array[2] - 0.5547) * (value_array[2] - 0.5547)))))))) + (3.2 * (exp(-(((0.1 * ((value_array[0] - 0.03815) * (value_array[0] - 0.03815))) + (10.0 * ((value_array[1] - 0.5743) * (value_array[1] - 0.5743)))) + (35.0 * ((value_array[2] - 0.8828) * (value_array[2] - 0.8828))))))));\\n}\\nstd::string print_hartman3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"-(((((1) * (exp(-((((3) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (3689/10000)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (3689/10000)))) + ((10) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (117/1000)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (117/1000))))) + ((30) * ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (2673/10000)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (2673/10000)))))))) + ((6/5) * (exp(-((((1/10) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (4699/10000)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (4699/10000)))) + ((10) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (4387/10000)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (4387/10000))))) + ((35) * ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (747/1000)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (747/1000))))))))) + ((3) * (exp(-((((3) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (1091/10000)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (1091/10000)))) + ((10) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (2183/2500)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (2183/2500))))) + ((30) * ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (5547/10000)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (5547/10000))))))))) + ((16/5) * (exp(-((((1/10) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (763/20000)) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (763/20000)))) + ((10) * ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (5743/10000)) * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - (5743/10000))))) + ((35) * ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (2207/2500)) * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" - (2207/2500)))))))))\\";\\n}\\nbool check_input_hartman3(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 1.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 1.0)\\n        return false;\\n    if (0.0 > v[2])\\n        return false;\\n    if (v[2] > 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> hartman3_range = {std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0)};\\nconst int hartman3_variable_count = 3;","function_name":"hartman3","graph_name_base":"hartman3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.09e+04</td><td>6.49e+04</td><td>6.00e+04</td><td><b><i>4.01e+03</i></b></td><td>5.11e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.23e+03</td><td>5.67e+04</td><td>1.99e+04</td><td><b><i>4.67e+03</i></b></td><td>7.96e+03</td><td>3.22e+04</td><td>3.22e+04</td><td>3.22e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>8.16e+03</td><td>8.73e+03</td><td>3.53e+03</td><td><b><i>2.83e+03</i></b></td><td>3.99e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"square root","expr":"sqrt(X0)","num_variable":"1","file_name":"sqare_root.cpp","code":"// square root\\ntemplate <class T>\\ninline T square_root(const std::vector<T> &value_array)\\n{\\n    return sqrt(value_array[0]);\\n}\\nstd::string print_square_root(const std::vector<gmp::Rational> &value_array)\\n{\\n    return \\"Sqrt\\" + rational_to_string(value_array[0]);\\n}\\nbool check_input_square_root(const std::vector<double> &value_array)\\n{\\n    if (value_array[0] < 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> square_root_range = {std::uniform_real_distribution<double>(0, RAND_MAX)};\\nconst int square_root_variable_count = 1;","function_name":"square_root","graph_name_base":"SQUARE ROOT","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.17e+02</td><td>1.52e+03</td><td>7.44e+01</td><td>7.40e+01</td><td><b><i>7.36e+01</i></b></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.57e+01</td><td>4.34e+02</td><td>2.42e+01</td><td>2.42e+01</td><td><b><i>2.41e+01</i></b></td><td>6.20e+01</td><td>5.99e+01</td><td>5.86e+01</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>9.46e+01</td><td>1.15e+02</td><td><b><i>3.68e+01</i></b></td><td>3.87e+01</td><td>3.69e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench i4","expr":"sqrt(X0 + (X1 * X1))","num_variable":"2","file_name":"i4.cpp","code":"// FPBench i4\\ntemplate <class T>\\ninline T i4(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt(value_array[0] + (value_array[1] * value_array[1]));\\n}\\nstd::string print_i4(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_i4(const std::vector<double> &v)\\n{\\n    if (0.1 > v[0])\\n        return false;\\n    if (v[0] > 10.0)\\n        return false;\\n    if (-5.0 > v[1])\\n        return false;\\n    if (v[1] > 5.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> i4_range = {std::uniform_real_distribution<double>(0.1, 10.0), std::uniform_real_distribution<double>(-5.0, 5.0)};\\nconst int i4_variable_count = 2;","function_name":"i4","graph_name_base":"i4","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.84e+02</td><td>3.99e+03</td><td>2.05e+03</td><td><b><i>1.50e+02</i></b></td><td>1.92e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.36e+02</td><td>1.68e+03</td><td>3.47e+02</td><td><b><i>1.20e+02</i></b></td><td>1.83e+02</td><td>7.54e+02</td><td>7.54e+02</td><td>7.53e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.89e+02</td><td>3.87e+02</td><td>1.32e+02</td><td><b><i>1.09e+02</i></b></td><td>1.61e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.10","expr":"log(1.0 - X0) / log(1.0 + X0)","num_variable":"1","file_name":"NMSE_example_3_10.cpp","code":"// FPBench NMSE example 3.10\\ntemplate <class T>\\ninline T NMSE_example_3_10(const std::vector<T> &value_array)\\n{\\n\\treturn log(1.0 - value_array[0]) / log(1.0 + value_array[0]);\\n}\\nstd::string print_NMSE_example_3_10(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"log((1) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / log((1) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_example_3_10(const std::vector<double> &v)\\n{\\n    if (-1.0 >= v[0])\\n        return false;\\n    if (v[0] >= 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_10_range = {std::uniform_real_distribution<double>(-1.0, 1.0)};\\nconst int NMSE_example_3_10_variable_count = 1;","function_name":"NMSE_example_3_10","graph_name_base":"NMSE example 3.10","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.52e+03</td><td>5.28e+03</td><td>3.26e+03</td><td><b><i>1.01e+03</i></b></td><td>1.09e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.26e+03</td><td>5.35e+03</td><td><b><i>3.14e+02</i></b></td><td>5.40e+02</td><td>5.96e+02</td><td>1.58e+03</td><td>1.51e+03</td><td>1.51e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.61e+02</td><td>8.18e+02</td><td><b><i>3.59e+02</i></b></td><td>4.67e+02</td><td>5.16e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench test06_sums4, sum1","expr":"((X0 + X1) + X2) + X3","num_variable":"4","file_name":"test06_sums4_sum1.cpp","code":"// FPBench test06_sums4, sum1\\ntemplate <class T>\\ninline T test06_sums4_sum1(const std::vector<T> &value_array)\\n{\\n\\treturn ((value_array[0] + value_array[1]) + value_array[2]) + value_array[3];\\n}\\nstd::string print_test06_sums4_sum1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\";\\n}\\nbool check_input_test06_sums4_sum1(const std::vector<double> &v)\\n{\\n    if (-1e-05 >= v[0])\\n        return false;\\n    if (v[0] >= 1.00001)\\n        return false;\\n    if (0.0 >= v[1])\\n        return false;\\n    if (v[1] >= 1.0)\\n        return false;\\n    if (0.0 >= v[2])\\n        return false;\\n    if (v[2] >= 1.0)\\n        return false;\\n    if (0.0 >= v[3])\\n        return false;\\n    if (v[3] >= 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> test06_sums4_sum1_range = {std::uniform_real_distribution<double>(-1e-05, 1.00001), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0)};\\nconst int test06_sums4_sum1_variable_count = 4;","function_name":"test06_sums4_sum1","graph_name_base":"test06_sums4, sum1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.39e+02</td><td>2.93e+03</td><td>1.35e+03</td><td><b><i>7.19e+01</i></b></td><td>1.19e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.95e+02</td><td>3.23e+03</td><td>5.46e+01</td><td><b><i>3.33e+01</i></b></td><td>6.48e+01</td><td>9.83e+02</td><td>9.82e+02</td><td>9.83e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.58e+02</td><td>3.65e+02</td><td>9.47e+01</td><td><b><i>5.79e+01</i></b></td><td>9.82e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench i6","expr":"sin(X0 * X1)","num_variable":"2","file_name":"i6.cpp","code":"// FPBench i6\\ntemplate <class T>\\ninline T i6(const std::vector<T> &value_array)\\n{\\n\\treturn sin(value_array[0] * value_array[1]);\\n}\\nstd::string print_i6(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sin(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")\\";\\n}\\nbool check_input_i6(const std::vector<double> &v)\\n{\\n    if (0.1 > v[0])\\n        return false;\\n    if (v[0] > 10.0)\\n        return false;\\n    if (-5.0 > v[1])\\n        return false;\\n    if (v[1] > 5.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> i6_range = {std::uniform_real_distribution<double>(0.1, 10.0), std::uniform_real_distribution<double>(-5.0, 5.0)};\\nconst int i6_variable_count = 2;","function_name":"i6","graph_name_base":"i6","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.85e+02</td><td>6.31e+03</td><td>6.93e+02</td><td><b><i>2.98e+02</i></b></td><td>3.12e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.90e+02</td><td>7.11e+03</td><td><b><i>2.99e+02</i></b></td><td>3.38e+02</td><td>3.83e+02</td><td>3.26e+03</td><td>3.26e+03</td><td>3.26e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.74e+02</td><td>1.03e+03</td><td>3.27e+02</td><td><b><i>3.22e+02</i></b></td><td>3.40e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench exp1x","expr":"(exp(X0) - 1.0) / X0","num_variable":"1","file_name":"exp1x.cpp","code":"// FPBench exp1x\\ntemplate <class T>\\ninline T exp1x(const std::vector<T> &value_array)\\n{\\n\\treturn (exp(value_array[0]) - 1.0) / value_array[0];\\n}\\nstd::string print_exp1x(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (1)) / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\";\\n}\\nbool check_input_exp1x(const std::vector<double> &v)\\n{\\n    if (0.01 > v[0])\\n        return false;\\n    if (v[0] > 0.5)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> exp1x_range = {std::uniform_real_distribution<double>(0.01, 0.5)};\\nconst int exp1x_variable_count = 1;","function_name":"exp1x","graph_name_base":"exp1x","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.93e+02</td><td>3.27e+03</td><td>2.33e+03</td><td><b><i>3.93e+02</i></b></td><td>4.43e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.02e+02</td><td>2.55e+03</td><td><b><i>2.34e+02</i></b></td><td>2.95e+02</td><td>3.30e+02</td><td>7.96e+02</td><td>7.97e+02</td><td>7.98e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.63e+02</td><td>5.25e+02</td><td><b><i>2.62e+02</i></b></td><td>3.21e+02</td><td>3.53e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle4","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle4.cpp","code":"// FPBench triangle4\\ntemplate <class T>\\ninline T triangle4(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle4(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle4(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/10000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/10000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/10000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle4_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle4_variable_count = 3;","function_name":"triangle4","graph_name_base":"triangle4","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.72e+04</td><td>1.35e+04</td><td><b><i>5.60e+02</i></b></td><td>9.22e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.48e+03</td><td>2.69e+04</td><td>5.00e+03</td><td><b><i>1.04e+03</i></b></td><td>1.97e+03</td><td>7.50e+03</td><td>7.50e+03</td><td>7.50e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.87e+03</td><td>2.59e+03</td><td>8.90e+02</td><td><b><i>6.09e+02</i></b></td><td>9.73e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench matrixDeterminant","expr":"((((X0 * X4) * X8) + ((X1 * X5) * X6)) + ((X2 * X3) * X7)) - ((((X2 * X4) * X6) + ((X1 * X3) * X8)) + ((X0 * X5) * X7))","num_variable":"9","file_name":"matrixDeterminant.cpp","code":"// FPBench matrixDeterminant\\ntemplate <class T>\\ninline T matrixDeterminant(const std::vector<T> &value_array)\\n{\\n\\treturn ((((value_array[0] * value_array[4]) * value_array[8]) + ((value_array[1] * value_array[5]) * value_array[6])) + ((value_array[2] * value_array[3]) * value_array[7])) - ((((value_array[2] * value_array[4]) * value_array[6]) + ((value_array[1] * value_array[3]) * value_array[8])) + ((value_array[0] * value_array[5]) * value_array[7]));\\n}\\nstd::string print_matrixDeterminant(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[8]) + \\")\\" + \\") + ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[6]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[7]) + \\")\\" + \\")) - ((((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[6]) + \\")\\" + \\") + ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[8]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[7]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_matrixDeterminant(const std::vector<double> &v)\\n{\\n    if (-10.0 > v[0])\\n        return false;\\n    if (v[0] > 10.0)\\n        return false;\\n    if (-10.0 > v[1])\\n        return false;\\n    if (v[1] > 10.0)\\n        return false;\\n    if (-10.0 > v[2])\\n        return false;\\n    if (v[2] > 10.0)\\n        return false;\\n    if (-10.0 > v[3])\\n        return false;\\n    if (v[3] > 10.0)\\n        return false;\\n    if (-10.0 > v[4])\\n        return false;\\n    if (v[4] > 10.0)\\n        return false;\\n    if (-10.0 > v[5])\\n        return false;\\n    if (v[5] > 10.0)\\n        return false;\\n    if (-10.0 > v[6])\\n        return false;\\n    if (v[6] > 10.0)\\n        return false;\\n    if (-10.0 > v[7])\\n        return false;\\n    if (v[7] > 10.0)\\n        return false;\\n    if (-10.0 > v[8])\\n        return false;\\n    if (v[8] > 10.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> matrixDeterminant_range = {std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0)};\\nconst int matrixDeterminant_variable_count = 9;","function_name":"matrixDeterminant","graph_name_base":"matrixDeterminant","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.53e+03</td><td>1.98e+04</td><td>1.61e+04</td><td><b><i>5.26e+02</i></b></td><td>7.99e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.53e+03</td><td>1.68e+04</td><td>3.65e+03</td><td><b><i>1.09e+03</i></b></td><td>1.98e+03</td><td>5.69e+03</td><td>5.68e+03</td><td>5.68e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.74e+03</td><td>2.38e+03</td><td>7.28e+02</td><td><b><i>5.87e+02</i></b></td><td>7.56e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench carthesianToPolar, radius","expr":"sqrt((X0 * X0) + (X1 * X1))","num_variable":"2","file_name":"carthesianToPolar_radius.cpp","code":"// FPBench carthesianToPolar, radius\\ntemplate <class T>\\ninline T carthesianToPolar_radius(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((value_array[0] * value_array[0]) + (value_array[1] * value_array[1]));\\n}\\nstd::string print_carthesianToPolar_radius(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_carthesianToPolar_radius(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 100.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 100.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> carthesianToPolar_radius_range = {std::uniform_real_distribution<double>(1.0, 100.0), std::uniform_real_distribution<double>(1.0, 100.0)};\\nconst int carthesianToPolar_radius_variable_count = 2;","function_name":"carthesianToPolar_radius","graph_name_base":"carthesianToPolar, radius","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.24e+02</td><td>5.78e+03</td><td>3.26e+03</td><td><b><i>1.63e+02</i></b></td><td>2.11e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.98e+02</td><td>5.53e+03</td><td><b><i>7.87e+01</i></b></td><td>1.53e+02</td><td>2.71e+02</td><td>1.08e+03</td><td>1.08e+03</td><td>1.08e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.82e+02</td><td>5.05e+02</td><td>2.26e+02</td><td><b><i>1.48e+02</i></b></td><td>1.97e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.4.3","expr":"log((1.0 - X0) / (1.0 + X0))","num_variable":"1","file_name":"NMSE_problem_3_4_3.cpp","code":"// FPBench NMSE problem 3.4.3\\ntemplate <class T>\\ninline T NMSE_problem_3_4_3(const std::vector<T> &value_array)\\n{\\n\\treturn log((1.0 - value_array[0]) / (1.0 + value_array[0]));\\n}\\nstd::string print_NMSE_problem_3_4_3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"log(((1) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / ((1) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_NMSE_problem_3_4_3(const std::vector<double> &v)\\n{\\n    if (-1.0 >= v[0])\\n        return false;\\n    if (v[0] >= 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_4_3_range = {std::uniform_real_distribution<double>(-1.0, 1.0)};\\nconst int NMSE_problem_3_4_3_variable_count = 1;","function_name":"NMSE_problem_3_4_3","graph_name_base":"NMSE problem 3.4.3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>9.74e+02</td><td>3.89e+03</td><td>2.94e+03</td><td><b><i>5.21e+02</i></b></td><td>5.85e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.29e+02</td><td>4.59e+03</td><td><b><i>2.86e+02</i></b></td><td>3.44e+02</td><td>4.39e+02</td><td>1.20e+03</td><td>1.20e+03</td><td>1.20e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.11e+02</td><td>6.65e+02</td><td>4.80e+02</td><td><b><i>3.34e+02</i></b></td><td>4.06e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench test03_nonlin2","expr":"(X0 + X1) / (X0 - X1)","num_variable":"2","file_name":"test03_nonlin2.cpp","code":"// FPBench test03_nonlin2\\ntemplate <class T>\\ninline T test03_nonlin2(const std::vector<T> &value_array)\\n{\\n\\treturn (value_array[0] + value_array[1]) / (value_array[0] - value_array[1]);\\n}\\nstd::string print_test03_nonlin2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")\\";\\n}\\nbool check_input_test03_nonlin2(const std::vector<double> &v)\\n{\\n    if (0.0 >= v[0])\\n        return false;\\n    if (v[0] >= 1.0)\\n        return false;\\n    if (-1.0 >= v[1])\\n        return false;\\n    if (v[1] >= -0.1)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> test03_nonlin2_range = {std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(-1.0, -0.1)};\\nconst int test03_nonlin2_variable_count = 2;","function_name":"test03_nonlin2","graph_name_base":"test03_nonlin2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.46e+02</td><td>2.67e+03</td><td>2.41e+03</td><td><b><i>8.15e+01</i></b></td><td>1.16e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.37e+02</td><td>2.88e+03</td><td>3.80e+02</td><td><b><i>9.76e+01</i></b></td><td>1.56e+02</td><td>9.88e+02</td><td>9.86e+02</td><td>9.88e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.49e+02</td><td>3.58e+02</td><td>1.26e+02</td><td><b><i>7.83e+01</i></b></td><td>1.07e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE problem 3.4.2","expr":"(X2 * (exp((X0 + X1) * X2) - 1.0)) / ((exp(X0 * X2) - 1.0) * (exp(X1 * X2) - 1.0))","num_variable":"3","file_name":"NMSE_problem_3_4_2.cpp","code":"// FPBench NMSE problem 3.4.2\\ntemplate <class T>\\ninline T NMSE_problem_3_4_2(const std::vector<T> &value_array)\\n{\\n\\treturn (value_array[2] * (exp((value_array[0] + value_array[1]) * value_array[2]) - 1.0)) / ((exp(value_array[0] * value_array[2]) - 1.0) * (exp(value_array[1] * value_array[2]) - 1.0));\\n}\\nstd::string print_NMSE_problem_3_4_2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * (exp((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - (1))) / ((exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - (1)) * (exp(\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - (1)))\\";\\n}\\nbool check_input_NMSE_problem_3_4_2(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_problem_3_4_2_range = {std::uniform_real_distribution<double>(-12.5, 12.5), std::uniform_real_distribution<double>(-12.5, 12.5), std::uniform_real_distribution<double>(-25, 25)};\\nconst int NMSE_problem_3_4_2_variable_count = 3;","function_name":"NMSE_problem_3_4_2","graph_name_base":"NMSE problem 3.4.2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.78e+03</td><td>1.43e+04</td><td>1.20e+04</td><td><b><i>2.03e+03</i></b></td><td>2.24e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.86e+03</td><td>1.95e+04</td><td>3.51e+03</td><td><b><i>1.45e+03</i></b></td><td>1.96e+03</td><td>4.84e+03</td><td>4.84e+03</td><td>4.82e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.72e+03</td><td>1.85e+03</td><td>1.30e+03</td><td><b><i>1.14e+03</i></b></td><td>1.33e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench doppler1","expr":"(-(331.4 + (0.6 * X2)) * X1) / (((331.4 + (0.6 * X2)) + X0) * ((331.4 + (0.6 * X2)) + X0))","num_variable":"3","file_name":"doppler1.cpp","code":"// FPBench doppler1\\ntemplate <class T>\\ninline T doppler1(const std::vector<T> &value_array)\\n{\\n\\treturn (-(331.4 + (0.6 * value_array[2])) * value_array[1]) / (((331.4 + (0.6 * value_array[2])) + value_array[0]) * ((331.4 + (0.6 * value_array[2])) + value_array[0]));\\n}\\nstd::string print_doppler1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(-((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") / ((((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * (((1657/5) + ((3/5) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_doppler1(const std::vector<double> &v)\\n{\\n    if (-100.0 > v[0])\\n        return false;\\n    if (v[0] > 100.0)\\n        return false;\\n    if (20.0 > v[1])\\n        return false;\\n    if (v[1] > 20000.0)\\n        return false;\\n    if (-30.0 > v[2])\\n        return false;\\n    if (v[2] > 50.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> doppler1_range = {std::uniform_real_distribution<double>(-100.0, 100.0), std::uniform_real_distribution<double>(20.0, 20000.0), std::uniform_real_distribution<double>(-30.0, 50.0)};\\nconst int doppler1_variable_count = 3;","function_name":"doppler1","graph_name_base":"doppler1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.67e+03</td><td>1.25e+04</td><td>1.20e+04</td><td><b><i>2.58e+02</i></b></td><td>4.39e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>9.49e+02</td><td>1.67e+04</td><td>2.47e+03</td><td><b><i>4.37e+02</i></b></td><td>4.81e+02</td><td>3.73e+03</td><td>3.73e+03</td><td>3.73e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.01e+03</td><td>1.40e+03</td><td>3.95e+02</td><td><b><i>2.99e+02</i></b></td><td>4.76e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench nonlin2","expr":"((X0 * X1) - 1.0) / (((X0 * X1) * (X0 * X1)) - 1.0)","num_variable":"2","file_name":"nonlin2.cpp","code":"// FPBench nonlin2\\ntemplate <class T>\\ninline T nonlin2(const std::vector<T> &value_array)\\n{\\n\\treturn ((value_array[0] * value_array[1]) - 1.0) / (((value_array[0] * value_array[1]) * (value_array[0] * value_array[1])) - 1.0);\\n}\\nstd::string print_nonlin2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (1)) / (((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - (1))\\";\\n}\\nbool check_input_nonlin2(const std::vector<double> &v)\\n{\\n    if (1.001 > v[0])\\n        return false;\\n    if (v[0] > 2.0)\\n        return false;\\n    if (1.001 > v[1])\\n        return false;\\n    if (v[1] > 2.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> nonlin2_range = {std::uniform_real_distribution<double>(1.001, 2.0), std::uniform_real_distribution<double>(1.001, 2.0)};\\nconst int nonlin2_variable_count = 2;","function_name":"nonlin2","graph_name_base":"nonlin2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.06e+03</td><td>7.03e+03</td><td>6.62e+03</td><td><b><i>1.80e+02</i></b></td><td>2.90e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.65e+02</td><td>1.05e+04</td><td>1.27e+03</td><td><b><i>2.91e+02</i></b></td><td>5.89e+02</td><td>2.33e+03</td><td>2.33e+03</td><td>2.33e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.37e+02</td><td>8.42e+02</td><td>2.78e+02</td><td><b><i>2.06e+02</i></b></td><td>2.96e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle5","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle5.cpp","code":"// FPBench triangle5\\ntemplate <class T>\\ninline T triangle5(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle5(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle5(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/100000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/100000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/100000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle5_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle5_variable_count = 3;","function_name":"triangle5","graph_name_base":"triangle5","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.67e+04</td><td>1.36e+04</td><td><b><i>5.60e+02</i></b></td><td>9.22e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.40e+03</td><td>2.68e+04</td><td>4.51e+03</td><td><b><i>1.04e+03</i></b></td><td>1.99e+03</td><td>7.56e+03</td><td>7.56e+03</td><td>7.56e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.75e+03</td><td>2.44e+03</td><td>8.38e+02</td><td><b><i>5.77e+02</i></b></td><td>9.20e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench test06_sums4, sum2","expr":"(X0 + X1) + (X2 + X3)","num_variable":"4","file_name":"test06_sums4_sum2.cpp","code":"// FPBench test06_sums4, sum2\\ntemplate <class T>\\ninline T test06_sums4_sum2(const std::vector<T> &value_array)\\n{\\n\\treturn (value_array[0] + value_array[1]) + (value_array[2] + value_array[3]);\\n}\\nstd::string print_test06_sums4_sum2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")\\";\\n}\\nbool check_input_test06_sums4_sum2(const std::vector<double> &v)\\n{\\n    if (-1e-05 >= v[0])\\n        return false;\\n    if (v[0] >= 1.00001)\\n        return false;\\n    if (0.0 >= v[1])\\n        return false;\\n    if (v[1] >= 1.0)\\n        return false;\\n    if (0.0 >= v[2])\\n        return false;\\n    if (v[2] >= 1.0)\\n        return false;\\n    if (0.0 >= v[3])\\n        return false;\\n    if (v[3] >= 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> test06_sums4_sum2_range = {std::uniform_real_distribution<double>(-1e-05, 1.00001), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0), std::uniform_real_distribution<double>(0.0, 1.0)};\\nconst int test06_sums4_sum2_variable_count = 4;","function_name":"test06_sums4_sum2","graph_name_base":"test06_sums4, sum2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.17e+02</td><td>3.14e+03</td><td>1.23e+03</td><td><b><i>6.98e+01</i></b></td><td>1.10e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.95e+02</td><td>3.18e+03</td><td>3.09e+02</td><td><b><i>3.33e+01</i></b></td><td>6.20e+01</td><td>9.80e+02</td><td>9.80e+02</td><td>9.80e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.71e+02</td><td>3.70e+02</td><td>9.70e+01</td><td><b><i>5.68e+01</i></b></td><td>9.02e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.3","expr":"sin(X0 + X1) - sin(X0)","num_variable":"2","file_name":"NMSE_example_3_3.cpp","code":"// FPBench NMSE example 3.3\\ntemplate <class T>\\ninline T NMSE_example_3_3(const std::vector<T> &value_array)\\n{\\n\\treturn sin(value_array[0] + value_array[1]) - sin(value_array[0]);\\n}\\nstd::string print_NMSE_example_3_3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sin(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - sin(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_example_3_3(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_3_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_example_3_3_variable_count = 2;","function_name":"NMSE_example_3_3","graph_name_base":"NMSE example 3.3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>7.96e+02</td><td>1.08e+04</td><td>1.52e+03</td><td><b><i>4.91e+02</i></b></td><td>5.24e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.82e+02</td><td>1.97e+04</td><td>6.98e+02</td><td><b><i>4.76e+02</i></b></td><td>5.07e+02</td><td>6.78e+03</td><td>6.69e+03</td><td>6.72e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.48e+02</td><td>2.18e+03</td><td><b><i>4.61e+02</i></b></td><td>6.24e+02</td><td>6.67e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 3","expr":"(X0 * (X0 / X1) * (X0 / X1 / X2) - X3 * (X3 / X4) * (X3 / X4 / X5) + X6 * (X6 / X7) * (X6 / X7 / X8)) * X9","num_variable":"10","file_name":"expr3.cpp","code":"// Arithmetic expression 3\\ntemplate <class T>\\ninline T expr3(const std::vector<T> &value_array)\\n{\\n    return (value_array[0] * (value_array[0] / value_array[1]) * (value_array[0] / value_array[1] / value_array[2]) - value_array[3] * (value_array[3] / value_array[4]) * (value_array[3] / value_array[4] / value_array[5]) + value_array[6] * (value_array[6] / value_array[7]) * (value_array[6] / value_array[7] / value_array[8])) * value_array[9];\\n}\\nstd::string print_expr3(const std::vector<gmp::Rational> &value_array)\\n{\\n    return \\"(\\" + rational_to_string(value_array[0]) + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"/\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"/\\" + rational_to_string(value_array[1]) + \\"/\\" + rational_to_string(value_array[2]) + \\")\\" + \\"-\\" + rational_to_string(value_array[3]) + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\"/\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\"/\\" + rational_to_string(value_array[4]) + \\"/\\" + rational_to_string(value_array[5]) + \\")\\" + \\"+\\" + rational_to_string(value_array[6]) + \\"*\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"/\\" + rational_to_string(value_array[7]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"/\\" + rational_to_string(value_array[7]) + \\"/\\" + rational_to_string(value_array[8]) + \\")\\" + \\")\\" + \\"*\\" + rational_to_string(value_array[9]);\\n}\\nbool check_input_expr3(const std::vector<double> &value_array)\\n{\\n    if (value_array[1] == 0)\\n        return false;\\n    if (value_array[2] == 0)\\n        return false;\\n    if (value_array[4] == 0)\\n        return false;\\n    if (value_array[5] == 0)\\n        return false;\\n    if (value_array[7] == 0)\\n        return false;\\n    if (value_array[8] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr3_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr3_variable_count = 10;","function_name":"expr3","graph_name_base":"ARITHMETIC EXPRESSION 3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.78e+03</td><td>2.04e+04</td><td>2.07e+04</td><td><b><i>6.02e+02</i></b></td><td>8.89e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.71e+03</td><td>1.59e+04</td><td>4.61e+03</td><td><b><i>1.27e+03</i></b></td><td>1.91e+03</td><td>6.58e+03</td><td>6.58e+03</td><td>6.58e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.53e+03</td><td>2.20e+03</td><td>7.90e+02</td><td><b><i>6.34e+02</i></b></td><td>8.78e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle8","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle8.cpp","code":"// FPBench triangle8\\ntemplate <class T>\\ninline T triangle8(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle8(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle8(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/100000000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/100000000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/100000000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle8_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle8_variable_count = 3;","function_name":"triangle8","graph_name_base":"triangle8","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.06e+03</td><td>1.69e+04</td><td>1.35e+04</td><td><b><i>5.61e+02</i></b></td><td>9.22e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.74e+04</td><td>4.78e+03</td><td><b><i>1.05e+03</i></b></td><td>1.97e+03</td><td>7.53e+03</td><td>7.55e+03</td><td>7.53e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.88e+03</td><td>2.58e+03</td><td>8.90e+02</td><td><b><i>6.09e+02</i></b></td><td>9.75e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 1","expr":"cos((cos(cos(X5) + exp((X3) / (X2)))) * (sin(sqrt(X4) + X0 + X1 - sqrt(X3 + X2))))","num_variable":"6","file_name":"extra_function1.cpp","code":"// Composite expression 1\\ntemplate <class T>\\ninline T extra_function1(const std::vector<T> &value_array)\\n{\\n    return cos((cos(cos(value_array[5]) + exp((value_array[3]) / (value_array[2])))) * (sin(sqrt(value_array[4]) + value_array[0] + value_array[1] - sqrt(value_array[3] + value_array[2]))));\\n}\\nstd::string print_extra_function1(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"cos\\" + \\"(\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"+\\" + \\"Exp\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"+\\" + rational_to_string(value_array[0]) + \\"+\\" + rational_to_string(value_array[1]) + \\"-\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[3]) + \\"+\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function1(const std::vector<double> &value_array)\\n{\\n    if (value_array[2] == 0)\\n        return false;\\n    if ((value_array[3]) / (value_array[2]) < -700)\\n        return false;\\n    if ((value_array[3]) / (value_array[2]) > 700)\\n        return false;\\n    if (value_array[4] < 0)\\n        return false;\\n    if (value_array[3] + value_array[2] < 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function1_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(0, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int extra_function1_variable_count = 6;","function_name":"extra_function1","graph_name_base":"RANDOM EXPRESSION 1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.06e+03</td><td>2.96e+04</td><td>7.48e+03</td><td><b><i>2.07e+03</i></b></td><td>2.26e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.39e+03</td><td>5.28e+04</td><td>3.16e+03</td><td><b><i>2.12e+03</i></b></td><td>2.40e+03</td><td>1.57e+04</td><td>1.57e+04</td><td>1.57e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.13e+03</td><td>4.36e+03</td><td>1.81e+03</td><td><b><i>1.76e+03</i></b></td><td>1.90e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle9","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle9.cpp","code":"// FPBench triangle9\\ntemplate <class T>\\ninline T triangle9(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle9(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle9(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 9.0)\\n        return false;\\n    if (1.0 > v[2])\\n        return false;\\n    if (v[2] > 9.0)\\n        return false;\\n    if ((v[0] + v[1]) <= (v[2] + 1.0/1000000000))\\n        return false;\\n    if ((v[0] + v[2]) <= (v[1] + 1.0/1000000000))\\n        return false;\\n    if ((v[1] + v[2]) <= (v[0] + 1.0/1000000000))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle9_range = {std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0), std::uniform_real_distribution<double>(1.0, 9.0)};\\nconst int triangle9_variable_count = 3;","function_name":"triangle9","graph_name_base":"triangle9","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.69e+04</td><td>1.36e+04</td><td><b><i>5.59e+02</i></b></td><td>9.19e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.69e+04</td><td>5.02e+03</td><td><b><i>1.04e+03</i></b></td><td>1.97e+03</td><td>7.50e+03</td><td>7.50e+03</td><td>7.49e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.61e+03</td><td>2.19e+03</td><td>7.53e+02</td><td><b><i>5.16e+02</i></b></td><td>8.27e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 2","expr":"X0 * (X0 + X1 * X2) / (X1 + X2 * X3) - X3 * (X4 + X5 / X6) / (X6 + X7) - X8 / X9","num_variable":"10","file_name":"expr2.cpp","code":"// Arithmetic expression 2\\ntemplate <class T>\\ninline T expr2(const std::vector<T> &value_array)\\n{\\n    return value_array[0] * (value_array[0] + value_array[1] * value_array[2]) / (value_array[1] + value_array[2] * value_array[3]) - value_array[3] * (value_array[4] + value_array[5] / value_array[6]) / (value_array[6] + value_array[7]) - value_array[8] / value_array[9];\\n}\\nstd::string print_expr2(const std::vector<gmp::Rational> &value_array)\\n{\\n    return rational_to_string(value_array[0]) + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"+\\" + rational_to_string(value_array[1]) + \\"*\\" + rational_to_string(value_array[2]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[1]) + \\"+\\" + rational_to_string(value_array[2]) + \\"*\\" + rational_to_string(value_array[3]) + \\")\\" + \\"-\\" + rational_to_string(value_array[3]) + \\"*\\" + \\"(\\" + rational_to_string(value_array[4]) + \\"+\\" + rational_to_string(value_array[5]) + \\"/\\" + rational_to_string(value_array[6]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"+\\" + rational_to_string(value_array[7]) + \\")\\" + \\"-\\" + rational_to_string(value_array[8]) + \\"/\\" + rational_to_string(value_array[9]);\\n}\\nbool check_input_expr2(const std::vector<double> &value_array)\\n{\\n    if (value_array[1] + value_array[2] * value_array[3] == 0)\\n        return false;\\n    if (value_array[6] == 0)\\n        return false;\\n    if (value_array[9] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr2_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr2_variable_count = 10;","function_name":"expr2","graph_name_base":"ARITHMETIC EXPRESSION 2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.14e+03</td><td>1.69e+04</td><td>1.42e+04</td><td><b><i>4.27e+02</i></b></td><td>7.02e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.21e+04</td><td>3.37e+03</td><td><b><i>7.45e+02</i></b></td><td>1.19e+03</td><td>4.91e+03</td><td>4.91e+03</td><td>4.91e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.16e+03</td><td>1.62e+03</td><td>5.30e+02</td><td><b><i>3.84e+02</i></b></td><td>5.74e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench turbine1","expr":"((3.0 + (2.0 / (X2 * X2))) - (((0.125 * (3.0 - (2.0 * X0))) * (((X1 * X1) * X2) * X2)) / (1.0 - X0))) - 4.5","num_variable":"3","file_name":"turbine1.cpp","code":"// FPBench turbine1\\ntemplate <class T>\\ninline T turbine1(const std::vector<T> &value_array)\\n{\\n\\treturn ((3.0 + (2.0 / (value_array[2] * value_array[2]))) - (((0.125 * (3.0 - (2.0 * value_array[0]))) * (((value_array[1] * value_array[1]) * value_array[2]) * value_array[2])) / (1.0 - value_array[0]))) - 4.5;\\n}\\nstd::string print_turbine1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((3) + ((2) / (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))) - ((((1/8) * ((3) - ((2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))) * (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) / ((1) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))) - (9/2)\\";\\n}\\nbool check_input_turbine1(const std::vector<double> &v)\\n{\\n    if (-4.5 > v[0])\\n        return false;\\n    if (v[0] > -0.3)\\n        return false;\\n    if (0.4 > v[1])\\n        return false;\\n    if (v[1] > 0.9)\\n        return false;\\n    if (3.8 > v[2])\\n        return false;\\n    if (v[2] > 7.8)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> turbine1_range = {std::uniform_real_distribution<double>(-4.5, -0.3), std::uniform_real_distribution<double>(0.4, 0.9), std::uniform_real_distribution<double>(3.8, 7.8)};\\nconst int turbine1_variable_count = 3;","function_name":"turbine1","graph_name_base":"turbine1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.16e+03</td><td>1.33e+04</td><td>1.03e+04</td><td><b><i>3.54e+02</i></b></td><td>6.61e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.16e+03</td><td>2.22e+04</td><td>2.72e+03</td><td><b><i>8.57e+02</i></b></td><td>1.47e+03</td><td>6.26e+03</td><td>6.26e+03</td><td>6.26e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.22e+03</td><td>1.66e+03</td><td>5.20e+02</td><td><b><i>3.77e+02</i></b></td><td>6.01e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench turbine3","expr":"((3.0 - (2.0 / (X2 * X2))) - (((0.125 * (1.0 + (2.0 * X0))) * (((X1 * X1) * X2) * X2)) / (1.0 - X0))) - 0.5","num_variable":"3","file_name":"turbine3.cpp","code":"// FPBench turbine3\\ntemplate <class T>\\ninline T turbine3(const std::vector<T> &value_array)\\n{\\n\\treturn ((3.0 - (2.0 / (value_array[2] * value_array[2]))) - (((0.125 * (1.0 + (2.0 * value_array[0]))) * (((value_array[1] * value_array[1]) * value_array[2]) * value_array[2])) / (1.0 - value_array[0]))) - 0.5;\\n}\\nstd::string print_turbine3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((3) - ((2) / (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))) - ((((1/8) * ((1) + ((2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))) * (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) / ((1) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))) - (1/2)\\";\\n}\\nbool check_input_turbine3(const std::vector<double> &v)\\n{\\n    if (-4.5 > v[0])\\n        return false;\\n    if (v[0] > -0.3)\\n        return false;\\n    if (0.4 > v[1])\\n        return false;\\n    if (v[1] > 0.9)\\n        return false;\\n    if (3.8 > v[2])\\n        return false;\\n    if (v[2] > 7.8)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> turbine3_range = {std::uniform_real_distribution<double>(-4.5, -0.3), std::uniform_real_distribution<double>(0.4, 0.9), std::uniform_real_distribution<double>(3.8, 7.8)};\\nconst int turbine3_variable_count = 3;","function_name":"turbine3","graph_name_base":"turbine3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.17e+03</td><td>1.25e+04</td><td>1.09e+04</td><td><b><i>3.60e+02</i></b></td><td>6.17e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.17e+03</td><td>2.12e+04</td><td>3.24e+03</td><td><b><i>8.51e+02</i></b></td><td>1.47e+03</td><td>5.99e+03</td><td>5.99e+03</td><td>5.99e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.34e+03</td><td>1.78e+03</td><td>5.63e+02</td><td><b><i>4.09e+02</i></b></td><td>6.53e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 3","expr":"((sqrt(sqrt(X2)) - sqrt(X0) - sin(sin(X3))) / (sqrt((sin(X5)) * ((X2) / (X0))) + X5)) * (cos(X4 + X3 + X1) - exp(cos((X4) / (X3))) - X1)","num_variable":"6","file_name":"extra_function3.cpp","code":"// Composite expression 3\\ntemplate <class T>\\ninline T extra_function3(const std::vector<T> &value_array)\\n{\\n    return ((sqrt(sqrt(value_array[2])) - sqrt(value_array[0]) - sin(sin(value_array[3]))) / (sqrt((sin(value_array[5])) * ((value_array[2]) / (value_array[0]))) + value_array[5])) * (cos(value_array[4] + value_array[3] + value_array[1]) - exp(cos((value_array[4]) / (value_array[3]))) - value_array[1]);\\n}\\nstd::string print_extra_function3(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"(\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\"-\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"-\\" + \\"sin\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\")\\" + \\")\\" + \\"+\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[4]) + \\"+\\" + rational_to_string(value_array[3]) + \\"+\\" + rational_to_string(value_array[1]) + \\")\\" + \\"-\\" + \\"Exp\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\")\\" + \\"-\\" + rational_to_string(value_array[1]) + \\")\\";\\n}\\nbool check_input_extra_function3(const std::vector<double> &value_array)\\n{\\n    if (value_array[2] < 0)\\n        return false;\\n    if (value_array[0] < 0)\\n        return false;\\n    if (value_array[0] == 0)\\n        return false;\\n    if ((sin(value_array[5])) * ((value_array[2]) / (value_array[0])) < 0)\\n        return false;\\n    if (sqrt((sin(value_array[5])) * ((value_array[2]) / (value_array[0]))) + value_array[5] == 0)\\n        return false;\\n    if (value_array[3] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function3_range = {std::uniform_real_distribution<double>(0, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(0, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int extra_function3_variable_count = 6;","function_name":"extra_function3","graph_name_base":"RANDOM EXPRESSION 3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.29e+03</td><td>4.37e+04</td><td>1.18e+04</td><td><b><i>2.72e+03</i></b></td><td>2.95e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.39e+03</td><td>6.73e+04</td><td>4.94e+03</td><td><b><i>2.99e+03</i></b></td><td>3.70e+03</td><td>1.96e+04</td><td>1.96e+04</td><td>1.96e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.04e+03</td><td>6.24e+03</td><td>2.32e+03</td><td><b><i>2.21e+03</i></b></td><td>2.42e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 2","expr":"exp(sqrt(exp(sqrt(exp(sqrt(X3))))))","num_variable":"6","file_name":"extra_function2.cpp","code":"// Composite expression 2\\ntemplate <class T>\\ninline T extra_function2(const std::vector<T> &value_array)\\n{\\n    return exp(sqrt(exp(sqrt(exp(sqrt(value_array[3]))))));\\n}\\nstd::string print_extra_function2(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"Exp\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"Exp\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"Exp\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function2(const std::vector<double> &value_array)\\n{\\n    if (value_array[3] < 0)\\n        return false;\\n    if (sqrt(value_array[3]) > 700)\\n        return false;\\n    if (sqrt(exp(sqrt(value_array[3]))) > 700)\\n        return false;\\n    if (sqrt(exp(sqrt(exp(sqrt(value_array[3]))))) > 700)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function2_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(0, 49000), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int extra_function2_variable_count = 6;","function_name":"extra_function2","graph_name_base":"RANDOM EXPRESSION 2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td><b><i>1.80e+03</i></b></td><td>8.62e+03</td><td>2.04e+03</td><td>2.04e+03</td><td>2.04e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.36e+03</td><td>1.02e+04</td><td>1.46e+03</td><td>1.45e+03</td><td>1.44e+03</td><td>1.33e+03</td><td><b><i>1.32e+03</i></b></td><td>1.33e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.20e+03</td><td><b><i>9.93e+02</i></b></td><td>1.15e+03</td><td>1.15e+03</td><td>1.14e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench delta4","expr":"(((((-X1 * X2) - (X0 * X3)) + (X1 * X4)) + (X2 * X5)) - (X4 * X5)) + (X0 * (((((-X0 + X1) + X2) - X3) + X4) + X5))","num_variable":"6","file_name":"delta4.cpp","code":"// FPBench delta4\\ntemplate <class T>\\ninline T delta4(const std::vector<T> &value_array)\\n{\\n\\treturn (((((-value_array[1] * value_array[2]) - (value_array[0] * value_array[3])) + (value_array[1] * value_array[4])) + (value_array[2] * value_array[5])) - (value_array[4] * value_array[5])) + (value_array[0] * (((((-value_array[0] + value_array[1]) + value_array[2]) - value_array[3]) + value_array[4]) + value_array[5]));\\n}\\nstd::string print_delta4(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((((-\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\")) + (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) - (\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) + (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * (((((-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_delta4(const std::vector<double> &v)\\n{\\n    if (4.0 > v[0])\\n        return false;\\n    if (v[0] > 6.3504)\\n        return false;\\n    if (4.0 > v[1])\\n        return false;\\n    if (v[1] > 6.3504)\\n        return false;\\n    if (4.0 > v[2])\\n        return false;\\n    if (v[2] > 6.3504)\\n        return false;\\n    if (4.0 > v[3])\\n        return false;\\n    if (v[3] > 6.3504)\\n        return false;\\n    if (4.0 > v[4])\\n        return false;\\n    if (v[4] > 6.3504)\\n        return false;\\n    if (4.0 > v[5])\\n        return false;\\n    if (v[5] > 6.3504)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> delta4_range = {std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504), std::uniform_real_distribution<double>(4.0, 6.3504)};\\nconst int delta4_variable_count = 6;","function_name":"delta4","graph_name_base":"delta4","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.42e+03</td><td>1.31e+04</td><td>1.18e+04</td><td><b><i>4.01e+02</i></b></td><td>7.69e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.18e+03</td><td>2.32e+04</td><td>2.48e+03</td><td><b><i>7.54e+02</i></b></td><td>1.72e+03</td><td>5.46e+03</td><td>5.46e+03</td><td>5.46e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.47e+03</td><td>1.97e+03</td><td>5.47e+02</td><td><b><i>3.73e+02</i></b></td><td>6.45e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 1","expr":"X0 / X1 * X2 / X3 * X4 / X5 * X6 / X7 * X8 / X9","num_variable":"10","file_name":"expr1.cpp","code":"// Arithmetic expression 1\\ntemplate <class T>\\ninline T expr1(const std::vector<T> &value_array)\\n{\\n    return value_array[0] / value_array[1] * value_array[2] / value_array[3] * value_array[4] / value_array[5] * value_array[6] / value_array[7] * value_array[8] / value_array[9];\\n}\\nstd::string print_expr1(const std::vector<gmp::Rational> &value_array)\\n{\\n    return rational_to_string(value_array[0]) + \\"/\\" + rational_to_string(value_array[1]) + \\"*\\" + rational_to_string(value_array[2]) + \\"/\\" + rational_to_string(value_array[3]) + \\"*\\" + rational_to_string(value_array[4]) + \\"/\\" + rational_to_string(value_array[5]) + \\"*\\" + rational_to_string(value_array[6]) + \\"/\\" + rational_to_string(value_array[7]) + \\"*\\" + rational_to_string(value_array[8]) + \\"/\\" + rational_to_string(value_array[9]);\\n}\\nbool check_input_expr1(const std::vector<double> &value_array)\\n{\\n    if (value_array[1] == 0)\\n        return false;\\n    if (value_array[3] == 0)\\n        return false;\\n    if (value_array[5] == 0)\\n        return false;\\n    if (value_array[7] == 0)\\n        return false;\\n    if (value_array[9] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr1_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr1_variable_count = 10;","function_name":"expr1","graph_name_base":"ARITHMETIC EXPRESSION 1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.51e+03</td><td>1.07e+04</td><td>1.05e+04</td><td><b><i>3.64e+02</i></b></td><td>5.83e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.16e+02</td><td>7.09e+03</td><td>2.09e+03</td><td><b><i>6.51e+02</i></b></td><td>1.16e+03</td><td>3.36e+03</td><td>3.34e+03</td><td>3.34e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.63e+02</td><td>1.15e+03</td><td>3.91e+02</td><td><b><i>3.64e+02</i></b></td><td>5.54e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench turbine2","expr":"((6.0 * X0) - (((0.5 * X0) * (((X1 * X1) * X2) * X2)) / (1.0 - X0))) - 2.5","num_variable":"3","file_name":"turbine2.cpp","code":"// FPBench turbine2\\ntemplate <class T>\\ninline T turbine2(const std::vector<T> &value_array)\\n{\\n\\treturn ((6.0 * value_array[0]) - (((0.5 * value_array[0]) * (((value_array[1] * value_array[1]) * value_array[2]) * value_array[2])) / (1.0 - value_array[0]))) - 2.5;\\n}\\nstd::string print_turbine2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((6) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - ((((1/2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) / ((1) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))) - (5/2)\\";\\n}\\nbool check_input_turbine2(const std::vector<double> &v)\\n{\\n    if (-4.5 > v[0])\\n        return false;\\n    if (v[0] > -0.3)\\n        return false;\\n    if (0.4 > v[1])\\n        return false;\\n    if (v[1] > 0.9)\\n        return false;\\n    if (3.8 > v[2])\\n        return false;\\n    if (v[2] > 7.8)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> turbine2_range = {std::uniform_real_distribution<double>(-4.5, -0.3), std::uniform_real_distribution<double>(0.4, 0.9), std::uniform_real_distribution<double>(3.8, 7.8)};\\nconst int turbine2_variable_count = 3;","function_name":"turbine2","graph_name_base":"turbine2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.49e+03</td><td>1.00e+04</td><td>8.91e+03</td><td><b><i>2.30e+02</i></b></td><td>4.28e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.52e+02</td><td>1.57e+04</td><td>2.09e+03</td><td><b><i>4.26e+02</i></b></td><td>7.69e+02</td><td>4.93e+03</td><td>4.92e+03</td><td>4.91e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.01e+03</td><td>1.45e+03</td><td>4.42e+02</td><td><b><i>3.28e+02</i></b></td><td>5.33e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.1","expr":"sqrt(X0 + 1.0) - sqrt(X0)","num_variable":"1","file_name":"NMSE_example_3_1.cpp","code":"// FPBench NMSE example 3.1\\ntemplate <class T>\\ninline T NMSE_example_3_1(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt(value_array[0] + 1.0) - sqrt(value_array[0]);\\n}\\nstd::string print_NMSE_example_3_1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1)) - sqrt(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_example_3_1(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_1_range = {std::uniform_real_distribution<double>(0, RAND_MAX)};\\nconst int NMSE_example_3_1_variable_count = 1;","function_name":"NMSE_example_3_1","graph_name_base":"NMSE example 3.1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.20e+02</td><td>4.37e+03</td><td>1.46e+03</td><td><b><i>1.19e+02</i></b></td><td>2.40e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.96e+02</td><td>1.66e+03</td><td><b><i>8.96e+01</i></b></td><td>1.17e+02</td><td>1.50e+02</td><td>8.60e+02</td><td>7.97e+02</td><td>7.97e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.31e+02</td><td>5.24e+02</td><td><b><i>1.48e+02</i></b></td><td>1.70e+02</td><td>2.18e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 5","expr":"X1 - (X0 + X5) * (((X6 - X2) / ((X9) / (X1)) + X8) * (((X8) / (X5) + X9 + X4) * (X4))) - ((X2 - X0 + X3 - X6 + X7 + X9 + (X4) * (X3)) * ((X2 + X6) / ((X0) / (X8)) + ((X1) / (X5)) / (X3))) / (X7)","num_variable":"10","file_name":"expr5.cpp","code":"// Arithmetic expression 5\\ntemplate <class T>\\ninline T expr5(const std::vector<T> &value_array)\\n{\\n    return value_array[1] - (value_array[0] + value_array[5]) * (((value_array[6] - value_array[2]) / ((value_array[9]) / (value_array[1])) + value_array[8]) * (((value_array[8]) / (value_array[5]) + value_array[9] + value_array[4]) * (value_array[4]))) - ((value_array[2] - value_array[0] + value_array[3] - value_array[6] + value_array[7] + value_array[9] + (value_array[4]) * (value_array[3])) * ((value_array[2] + value_array[6]) / ((value_array[0]) / (value_array[8])) + ((value_array[1]) / (value_array[5])) / (value_array[3]))) / (value_array[7]);\\n}\\nstd::string print_expr5(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + rational_to_string(value_array[1]) + \\"-\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"+\\" + rational_to_string(value_array[5]) + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"-\\" + rational_to_string(value_array[2]) + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[9]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\"+\\" + rational_to_string(value_array[8]) + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[8]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"+\\" + rational_to_string(value_array[9]) + \\"+\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\")\\" + \\")\\" + \\"-\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[2]) + \\"-\\" + rational_to_string(value_array[0]) + \\"+\\" + rational_to_string(value_array[3]) + \\"-\\" + rational_to_string(value_array[6]) + \\"+\\" + rational_to_string(value_array[7]) + \\"+\\" + rational_to_string(value_array[9]) + \\"+\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[2]) + \\"+\\" + rational_to_string(value_array[6]) + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[8]) + \\")\\" + \\")\\" + \\"+\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\";\\n}\\nbool check_input_expr5(const std::vector<double> &value_array)\\n{\\n    if (value_array[1] == 0)\\n        return false;\\n    if ((value_array[9]) / (value_array[1]) == 0)\\n        return false;\\n    if (value_array[5] == 0)\\n        return false;\\n    if (value_array[8] == 0)\\n        return false;\\n    if ((value_array[0]) / (value_array[8]) == 0)\\n        return false;\\n    if (value_array[3] == 0)\\n        return false;\\n    if (value_array[7] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr5_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr5_variable_count = 10;","function_name":"expr5","graph_name_base":"ARITHMETIC EXPRESSION 5","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.35e+03</td><td>2.90e+04</td><td>2.64e+04</td><td><b><i>8.45e+02</i></b></td><td>1.34e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.48e+03</td><td>2.86e+04</td><td>7.97e+03</td><td><b><i>1.61e+03</i></b></td><td>2.93e+03</td><td>9.72e+03</td><td>9.71e+03</td><td>9.71e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.38e+03</td><td>3.36e+03</td><td>1.09e+03</td><td><b><i>7.72e+02</i></b></td><td>1.27e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.5","expr":"atan(X0 + 1.0) - atan(X0)","num_variable":"1","file_name":"NMSE_example_3_5.cpp","code":"// FPBench NMSE example 3.5\\ntemplate <class T>\\ninline T NMSE_example_3_5(const std::vector<T> &value_array)\\n{\\n\\treturn atan(value_array[0] + 1.0) - atan(value_array[0]);\\n}\\nstd::string print_NMSE_example_3_5(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"atan(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1)) - atan(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_example_3_5(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_5_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_example_3_5_variable_count = 1;","function_name":"NMSE_example_3_5","graph_name_base":"NMSE example 3.5","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>7.32e+02</td><td>4.00e+03</td><td>1.61e+03</td><td><b><i>3.52e+02</i></b></td><td>4.47e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.46e+02</td><td>6.15e+03</td><td><b><i>2.57e+02</i></b></td><td>3.48e+02</td><td>3.90e+02</td><td>1.21e+03</td><td>1.15e+03</td><td>1.15e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.42e+02</td><td>9.98e+02</td><td><b><i>3.31e+02</i></b></td><td>4.41e+02</td><td>4.81e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench kepler0","expr":"((((X1 * X4) + (X2 * X5)) - (X1 * X2)) - (X4 * X5)) + (X0 * (((((-X0 + X1) + X2) - X3) + X4) + X5))","num_variable":"6","file_name":"kepler0.cpp","code":"// FPBench kepler0\\ntemplate <class T>\\ninline T kepler0(const std::vector<T> &value_array)\\n{\\n\\treturn ((((value_array[1] * value_array[4]) + (value_array[2] * value_array[5])) - (value_array[1] * value_array[2])) - (value_array[4] * value_array[5])) + (value_array[0] * (((((-value_array[0] + value_array[1]) + value_array[2]) - value_array[3]) + value_array[4]) + value_array[5]));\\n}\\nstd::string print_kepler0(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") + (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) - (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) - (\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) + (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * (((((-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_kepler0(const std::vector<double> &v)\\n{\\n    if (4.0 > v[0])\\n        return false;\\n    if (v[0] > 6.36)\\n        return false;\\n    if (4.0 > v[1])\\n        return false;\\n    if (v[1] > 6.36)\\n        return false;\\n    if (4.0 > v[2])\\n        return false;\\n    if (v[2] > 6.36)\\n        return false;\\n    if (4.0 > v[3])\\n        return false;\\n    if (v[3] > 6.36)\\n        return false;\\n    if (4.0 > v[4])\\n        return false;\\n    if (v[4] > 6.36)\\n        return false;\\n    if (4.0 > v[5])\\n        return false;\\n    if (v[5] > 6.36)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> kepler0_range = {std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36)};\\nconst int kepler0_variable_count = 6;","function_name":"kepler0","graph_name_base":"kepler0","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.11e+03</td><td>1.20e+04</td><td>9.54e+03</td><td><b><i>3.51e+02</i></b></td><td>6.64e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.06e+03</td><td>2.52e+04</td><td>2.96e+03</td><td><b><i>5.08e+02</i></b></td><td>8.21e+02</td><td>4.73e+03</td><td>4.73e+03</td><td>4.72e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.34e+03</td><td>1.77e+03</td><td>4.78e+02</td><td><b><i>3.30e+02</i></b></td><td>5.80e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE p42, positive","expr":"(-X1 + sqrt((X1 * X1) - (4.0 * (X0 * X2)))) / (2.0 * X0)","num_variable":"3","file_name":"NMSE_p42_positive.cpp","code":"// FPBench NMSE p42, positive\\ntemplate <class T>\\ninline T NMSE_p42_positive(const std::vector<T> &value_array)\\n{\\n\\treturn (-value_array[1] + sqrt((value_array[1] * value_array[1]) - (4.0 * (value_array[0] * value_array[2])))) / (2.0 * value_array[0]);\\n}\\nstd::string print_NMSE_p42_positive(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(-\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" + sqrt((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - ((4) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")))) / ((2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_p42_positive(const std::vector<double> &v)\\n{\\n    if ((v[1] * v[1]) < (4 * (v[0] * v[2])))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_p42_positive_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_p42_positive_variable_count = 3;","function_name":"NMSE_p42_positive","graph_name_base":"NMSE p42, positive","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.27e+03</td><td>8.24e+03</td><td>6.30e+03</td><td><b><i>2.81e+02</i></b></td><td>4.35e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.21e+02</td><td>1.25e+04</td><td>1.50e+03</td><td><b><i>5.29e+02</i></b></td><td>8.14e+02</td><td>2.76e+03</td><td>2.76e+03</td><td>2.76e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>8.59e+02</td><td>1.15e+03</td><td>4.23e+02</td><td><b><i>3.34e+02</i></b></td><td>4.76e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench test01_sum3","expr":"(((X0 + X1) - X2) + ((X1 + X2) - X0)) + ((X2 + X0) - X1)","num_variable":"3","file_name":"test01_sum3.cpp","code":"// FPBench test01_sum3\\ntemplate <class T>\\ninline T test01_sum3(const std::vector<T> &value_array)\\n{\\n\\treturn (((value_array[0] + value_array[1]) - value_array[2]) + ((value_array[1] + value_array[2]) - value_array[0])) + ((value_array[2] + value_array[0]) - value_array[1]);\\n}\\nstd::string print_test01_sum3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")\\";\\n}\\nbool check_input_test01_sum3(const std::vector<double> &v)\\n{\\n    if (1.0 >= v[0])\\n        return false;\\n    if (v[0] >= 2.0)\\n        return false;\\n    if (1.0 >= v[1])\\n        return false;\\n    if (v[1] >= 2.0)\\n        return false;\\n    if (1.0 >= v[2])\\n        return false;\\n    if (v[2] >= 2.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> test01_sum3_range = {std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0)};\\nconst int test01_sum3_variable_count = 3;","function_name":"test01_sum3","graph_name_base":"test01_sum3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.19e+03</td><td>6.14e+03</td><td>5.05e+03</td><td><b><i>1.79e+02</i></b></td><td>3.09e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.01e+02</td><td>1.04e+04</td><td>1.15e+03</td><td><b><i>1.40e+02</i></b></td><td>2.03e+02</td><td>2.64e+03</td><td>2.64e+03</td><td>2.64e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.40e+02</td><td>1.00e+03</td><td>2.24e+02</td><td><b><i>1.40e+02</i></b></td><td>2.49e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench triangle","expr":"sqrt((((((X0 + X1) + X2) / 2.0) * ((((X0 + X1) + X2) / 2.0) - X0)) * ((((X0 + X1) + X2) / 2.0) - X1)) * ((((X0 + X1) + X2) / 2.0) - X2))","num_variable":"3","file_name":"triangle.cpp","code":"// FPBench triangle\\ntemplate <class T>\\ninline T triangle(const std::vector<T> &value_array)\\n{\\n\\treturn sqrt((((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[0])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[1])) * ((((value_array[0] + value_array[1]) + value_array[2]) / 2.0) - value_array[2]));\\n}\\nstd::string print_triangle(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"sqrt((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * ((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") / (2)) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_triangle(const std::vector<double> &v)\\n{\\n    if (9.0 > v[0])\\n        return false;\\n    if (v[0] > 9.0)\\n        return false;\\n    if (4.71 > v[1])\\n        return false;\\n    if (v[1] > 4.89)\\n        return false;\\n    if (4.71 > v[2])\\n        return false;\\n    if (v[2] > 4.89)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> triangle_range = {std::uniform_real_distribution<double>(9.0, 9.0), std::uniform_real_distribution<double>(4.71, 4.89), std::uniform_real_distribution<double>(4.71, 4.89)};\\nconst int triangle_variable_count = 3;","function_name":"triangle","graph_name_base":"triangle","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.05e+03</td><td>1.77e+04</td><td>1.34e+04</td><td><b><i>5.60e+02</i></b></td><td>9.20e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.31e+03</td><td>2.69e+04</td><td>4.92e+03</td><td><b><i>1.03e+03</i></b></td><td>1.97e+03</td><td>7.52e+03</td><td>7.51e+03</td><td>7.51e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.77e+03</td><td>2.41e+03</td><td>8.32e+02</td><td><b><i>5.69e+02</i></b></td><td>9.11e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench azimuth","expr":"atan((cos(X1) * sin(X3 - X2)) / ((cos(X0) * sin(X1)) - ((sin(X0) * cos(X1)) * cos(X3 - X2))))","num_variable":"4","file_name":"azimuth.cpp","code":"// FPBench azimuth\\ntemplate <class T>\\ninline T azimuth(const std::vector<T> &value_array)\\n{\\n\\treturn atan((cos(value_array[1]) * sin(value_array[3] - value_array[2])) / ((cos(value_array[0]) * sin(value_array[1])) - ((sin(value_array[0]) * cos(value_array[1])) * cos(value_array[3] - value_array[2]))));\\n}\\nstd::string print_azimuth(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"atan((cos(\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * sin(\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) / ((cos(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * sin(\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - ((sin(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * cos(\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * cos(\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))))\\";\\n}\\nbool check_input_azimuth(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 0.4)\\n        return false;\\n    if (0.5 > v[1])\\n        return false;\\n    if (v[1] > 1.0)\\n        return false;\\n    if (0.0 > v[2])\\n        return false;\\n    if (v[2] > 3.14159265)\\n        return false;\\n    if (-3.14159265 > v[3])\\n        return false;\\n    if (v[3] > -0.5)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> azimuth_range = {std::uniform_real_distribution<double>(0.0, 0.4), std::uniform_real_distribution<double>(0.5, 1.0), std::uniform_real_distribution<double>(0.0, 3.14159265), std::uniform_real_distribution<double>(-3.14159265, -0.5)};\\nconst int azimuth_variable_count = 4;","function_name":"azimuth","graph_name_base":"azimuth","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.19e+03</td><td>4.35e+04</td><td>8.12e+03</td><td><b><i>1.99e+03</i></b></td><td>2.16e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.57e+03</td><td>8.08e+04</td><td>3.62e+03</td><td><b><i>2.08e+03</i></b></td><td>2.60e+03</td><td>2.37e+04</td><td>2.37e+04</td><td>2.36e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.60e+03</td><td>6.77e+03</td><td><b><i>2.06e+03</i></b></td><td>2.17e+03</td><td>2.32e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 10","expr":"sqrt(sin(X5)-(cos((cos(X6)) * (cos(X3))+sqrt(X1)-cos(X0))) * (X4)+(sqrt(cos(X6))+sqrt((X3) * (X4))) * ((X5-X0+cos(X2)) * (sqrt(X2)))-((sqrt(sqrt(X1))) * (sin(sin(X1)))) * ((X4+X2+X0-X5) * (cos(X6+X3))))","num_variable":"7","file_name":"extra_function10.cpp","code":"// Composite expression 10\\ntemplate <class T>\\ninline T extra_function10(const std::vector<T> &value_array)\\n{\\n    return sqrt(sin(value_array[5])-(cos((cos(value_array[6])) * (cos(value_array[3]))+sqrt(value_array[1])-cos(value_array[0]))) * (value_array[4])+(sqrt(cos(value_array[6]))+sqrt((value_array[3]) * (value_array[4]))) * ((value_array[5]-value_array[0]+cos(value_array[2])) * (sqrt(value_array[2])))-((sqrt(sqrt(value_array[1]))) * (sin(sin(value_array[1])))) * ((value_array[4]+value_array[2]+value_array[0]-value_array[5]) * (cos(value_array[6]+value_array[3]))));\\n}\\nstd::string print_extra_function10(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"Sqrt\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"-\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\"+ \\")\\" + \\"+\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"-\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[4])+ \\")\\" + \\"+\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\"+\\" + \\"Sqrt\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[4])+ \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[5]) + \\"-\\" + rational_to_string(value_array[0]) + \\"+\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\"+ \\")\\"+ \\")\\" + \\"-\\" + \\"(\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\"+ \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\"+\\" + rational_to_string(value_array[2]) + \\"+\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[5]) + \\")\\" + \\"*\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"+\\" + rational_to_string(value_array[3]) + \\")\\"+ \\")\\"+ \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function10(const std::vector<double> &value_array)\\n{\\n    if (value_array[1] < 0)\\n        return false;\\n    if (cos(value_array[6]) < 0)\\n        return false;\\n    if ((value_array[3]) * (value_array[4]) < 0)\\n        return false;\\n    if (value_array[2] < 0)\\n        return false;\\n    if (sin(value_array[5])-(cos((cos(value_array[6])) * (cos(value_array[3]))+sqrt(value_array[1])-cos(value_array[0]))) * (value_array[4])+(sqrt(cos(value_array[6]))+sqrt((value_array[3]) * (value_array[4]))) * ((value_array[5]-value_array[0]+cos(value_array[2])) * (sqrt(value_array[2])))-((sqrt(sqrt(value_array[1]))) * (sin(sin(value_array[1])))) * ((value_array[4]+value_array[2]+value_array[0]-value_array[5]) * (cos(value_array[6]+value_array[3]))) < 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function10_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(0, RAND_MAX), std::uniform_real_distribution<double>(0, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int extra_function10_variable_count = 7;","function_name":"extra_function10","graph_name_base":"RANDOM EXPRESSION 10","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.42e+03</td><td>8.44e+04</td><td>1.75e+04</td><td><b><i>3.54e+03</i></b></td><td>3.94e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.84e+03</td><td>1.17e+05</td><td>9.51e+03</td><td><b><i>4.43e+03</i></b></td><td>5.67e+03</td><td>4.02e+04</td><td>4.02e+04</td><td>4.02e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.96e+03</td><td>1.15e+04</td><td>3.65e+03</td><td><b><i>3.47e+03</i></b></td><td>3.81e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 6","expr":"cos((sin(X6) - (sin(X8 + X3) + sin((X0) * (X7))) * ((cos(X8)) * (X1))) * (X5 - (X4) * ((X1) * (X2)) - (X7) * (X0) - cos(X3) - (cos(sin(X5))) * (X2 - X1 - sin(X8)) + (cos(X4 - X6)) * (X3 + X0 - X5)) - ((X1) * (X6) + (X4) * (X5) - X6 - sin(X8)) * (X0) - (cos(cos(X2))) * (sin(X7) - X4 + X1) + X4 + cos(sin(sin(cos((X6) * (X3)))))) - X2 + (X3) * (sin(sin(cos(X7))))","num_variable":"9","file_name":"extra_function6.cpp","code":"// Composite expression 6\\ntemplate <class T>\\ninline T extra_function6(const std::vector<T> &value_array)\\n{\\n    return cos((sin(value_array[6]) - (sin(value_array[8] + value_array[3]) + sin((value_array[0]) * (value_array[7]))) * ((cos(value_array[8])) * (value_array[1]))) * (value_array[5] - (value_array[4]) * ((value_array[1]) * (value_array[2])) - (value_array[7]) * (value_array[0]) - cos(value_array[3]) - (cos(sin(value_array[5]))) * (value_array[2] - value_array[1] - sin(value_array[8])) + (cos(value_array[4] - value_array[6])) * (value_array[3] + value_array[0] - value_array[5])) - ((value_array[1]) * (value_array[6]) + (value_array[4]) * (value_array[5]) - value_array[6] - sin(value_array[8])) * (value_array[0]) - (cos(cos(value_array[2]))) * (sin(value_array[7]) - value_array[4] + value_array[1]) + value_array[4] + cos(sin(sin(cos((value_array[6]) * (value_array[3])))))) - value_array[2] + (value_array[3]) * (sin(sin(cos(value_array[7]))));\\n}\\nstd::string print_extra_function6(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"cos\\" + \\"(\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\"-\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[8]) + \\"+\\" + rational_to_string(value_array[3]) + \\")\\" + \\"+\\" + \\"sin\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[8]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[5]) + \\"-\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\"-\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"-\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"-\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[2]) + \\"-\\" + rational_to_string(value_array[1]) + \\"-\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[8]) + \\")\\" + \\")\\" + \\"+\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[4]) + \\"-\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\"+\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\"-\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\"+\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"-\\" + rational_to_string(value_array[6]) + \\"-\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[8]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"-\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\"-\\" + rational_to_string(value_array[4]) + \\"+\\" + rational_to_string(value_array[1]) + \\")\\" + \\"+\\" + rational_to_string(value_array[4]) + \\"+\\" + \\"cos\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"-\\" + rational_to_string(value_array[2]) + \\"+\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"*\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function6(const std::vector<double> &value_array)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function6_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int extra_function6_variable_count = 9;","function_name":"extra_function6","graph_name_base":"RANDOM EXPRESSION 6","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.12e+04</td><td>1.41e+05</td><td>3.76e+04</td><td><b><i>6.32e+03</i></b></td><td>7.12e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.47e+03</td><td>2.09e+05</td><td>1.75e+04</td><td><b><i>7.12e+03</i></b></td><td>9.23e+03</td><td>7.18e+04</td><td>7.15e+04</td><td>7.13e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>8.31e+03</td><td>2.11e+04</td><td>6.12e+03</td><td><b><i>5.96e+03</i></b></td><td>6.52e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"division","expr":"X0 / X1","num_variable":"2","file_name":"division.cpp","code":"// division\\ntemplate <class T>\\ninline T division(const std::vector<T> &value_array)\\n{\\n    return value_array[0] / value_array[1];\\n}\\nstd::string print_division(const std::vector<gmp::Rational> &value_array)\\n{\\n    return rational_to_string(value_array[0]) + \\"/\\" + rational_to_string(value_array[1]);\\n}\\nbool check_input_division(const std::vector<double> &value_array)\\n{\\n    if (value_array[1] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> division_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int division_variable_count = 2;","function_name":"division","graph_name_base":"DIVISION","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.22e+02</td><td>1.02e+03</td><td>1.10e+03</td><td><b><i>3.98e+01</i></b></td><td>4.44e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.01e+01</td><td>4.52e+02</td><td><b><i>3.94e+01</i></b></td><td>7.04e+01</td><td>7.99e+01</td><td>3.44e+02</td><td>3.43e+02</td><td>3.44e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>8.69e+01</td><td>1.24e+02</td><td>4.50e+01</td><td><b><i>4.27e+01</i></b></td><td>4.55e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 7","expr":"(exp(cos((X5) / (X0))) + ((cos(X3)) * (sin(X2))) / (sqrt(exp(X7))) - exp(exp((X4) / (X6))) - sin(sin(X1)) + (exp(X7)) * (cos(X2))) / ((X1) * (X6))","num_variable":"8","file_name":"extra_function7.cpp","code":"// Composite expression 7\\ntemplate <class T>\\ninline T extra_function7(const std::vector<T> &value_array)\\n{\\n    return (exp(cos((value_array[5]) / (value_array[0]))) + ((cos(value_array[3])) * (sin(value_array[2]))) / (sqrt(exp(value_array[7]))) - exp(exp((value_array[4]) / (value_array[6]))) - sin(sin(value_array[1])) + (exp(value_array[7])) * (cos(value_array[2]))) / ((value_array[1]) * (value_array[6]));\\n}\\nstd::string print_extra_function7(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"(\\" + \\"Exp\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\")\\" + \\")\\" + \\"+\\" + \\"(\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"Exp\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\")\\" + \\"-\\" + \\"Exp\\" + \\"(\\" + \\"Exp\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\")\\" + \\"-\\" + \\"sin\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\"+\\" + \\"(\\" + \\"Exp\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function7(const std::vector<double> &value_array)\\n{\\n    if (value_array[0] == 0)\\n        return false;\\n    if (value_array[7] < -700)\\n        return false;\\n    if (value_array[7] > 700)\\n        return false;\\n    if (sqrt(exp(value_array[7])) == 0)\\n        return false;\\n    if (value_array[6] == 0)\\n        return false;\\n    if ((value_array[4]) / (value_array[6]) < -700)\\n        return false;\\n    if ((value_array[4]) / (value_array[6]) > 700)\\n        return false;\\n    if (exp((value_array[4]) / (value_array[6])) > 700)\\n        return false;\\n    if ((value_array[1]) * (value_array[6]) == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function7_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-700, 700)};\\nconst int extra_function7_variable_count = 8;","function_name":"extra_function7","graph_name_base":"RANDOM EXPRESSION 7","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.90e+03</td><td>4.80e+04</td><td>1.46e+04</td><td><b><i>4.22e+03</i></b></td><td>4.44e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.28e+03</td><td>7.05e+04</td><td>6.18e+03</td><td><b><i>3.91e+03</i></b></td><td>4.48e+03</td><td>2.37e+04</td><td>2.35e+04</td><td>2.35e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.99e+03</td><td>7.67e+03</td><td>3.27e+03</td><td><b><i>3.14e+03</i></b></td><td>3.37e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench test05_nonlin1, test2","expr":"1.0 / (X0 + 1.0)","num_variable":"1","file_name":"test05_nonlin1_test2.cpp","code":"// FPBench test05_nonlin1, test2\\ntemplate <class T>\\ninline T test05_nonlin1_test2(const std::vector<T> &value_array)\\n{\\n\\treturn 1.0 / (value_array[0] + 1.0);\\n}\\nstd::string print_test05_nonlin1_test2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(1) / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1))\\";\\n}\\nbool check_input_test05_nonlin1_test2(const std::vector<double> &v)\\n{\\n    if (1.00001 >= v[0])\\n        return false;\\n    if (v[0] >= 2.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> test05_nonlin1_test2_range = {std::uniform_real_distribution<double>(1.00001, 2.0)};\\nconst int test05_nonlin1_test2_variable_count = 1;","function_name":"test05_nonlin1_test2","graph_name_base":"test05_nonlin1, test2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.99e+02</td><td>2.13e+03</td><td>1.83e+03</td><td><b><i>5.63e+01</i></b></td><td>8.16e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.52e+02</td><td>2.40e+03</td><td>3.68e+02</td><td><b><i>7.71e+01</i></b></td><td>1.28e+02</td><td>6.62e+02</td><td>6.60e+02</td><td>6.61e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.03e+02</td><td>2.55e+02</td><td>8.61e+01</td><td><b><i>6.11e+01</i></b></td><td>8.36e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench bspline3","expr":"-((X0 * X0) * X0) / 6.0","num_variable":"1","file_name":"bspline3.cpp","code":"// FPBench bspline3\\ntemplate <class T>\\ninline T bspline3(const std::vector<T> &value_array)\\n{\\n\\treturn -((value_array[0] * value_array[0]) * value_array[0]) / 6.0;\\n}\\nstd::string print_bspline3(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"-((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / (6)\\";\\n}\\nbool check_input_bspline3(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> bspline3_range = {std::uniform_real_distribution<double>(0.0, 1.0)};\\nconst int bspline3_variable_count = 1;","function_name":"bspline3","graph_name_base":"bspline3","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.30e+02</td><td>3.26e+03</td><td>3.29e+03</td><td><b><i>9.21e+01</i></b></td><td>1.40e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.18e+02</td><td>3.27e+03</td><td><b><i>5.50e+01</i></b></td><td>8.12e+01</td><td>2.21e+02</td><td>1.07e+03</td><td>1.07e+03</td><td>1.07e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.99e+02</td><td>4.19e+02</td><td>1.86e+02</td><td><b><i>1.75e+02</i></b></td><td>2.12e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench kepler1","expr":"(((((((X0 * X3) * (((-X0 + X1) + X2) - X3)) + (X1 * (((X0 - X1) + X2) + X3))) + (X2 * (((X0 + X1) - X2) + X3))) - ((X1 * X2) * X3)) - (X0 * X2)) - (X0 * X1)) - X3","num_variable":"4","file_name":"kepler1.cpp","code":"// FPBench kepler1\\ntemplate <class T>\\ninline T kepler1(const std::vector<T> &value_array)\\n{\\n\\treturn (((((((value_array[0] * value_array[3]) * (((-value_array[0] + value_array[1]) + value_array[2]) - value_array[3])) + (value_array[1] * (((value_array[0] - value_array[1]) + value_array[2]) + value_array[3]))) + (value_array[2] * (((value_array[0] + value_array[1]) - value_array[2]) + value_array[3]))) - ((value_array[1] * value_array[2]) * value_array[3])) - (value_array[0] * value_array[2])) - (value_array[0] * value_array[1])) - value_array[3];\\n}\\nstd::string print_kepler1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * (((-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * (((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\"))) + (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * (((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\"))) - ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) - (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) - (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\";\\n}\\nbool check_input_kepler1(const std::vector<double> &v)\\n{\\n    if (4.0 > v[0])\\n        return false;\\n    if (v[0] > 6.36)\\n        return false;\\n    if (4.0 > v[1])\\n        return false;\\n    if (v[1] > 6.36)\\n        return false;\\n    if (4.0 > v[2])\\n        return false;\\n    if (v[2] > 6.36)\\n        return false;\\n    if (4.0 > v[3])\\n        return false;\\n    if (v[3] > 6.36)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> kepler1_range = {std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36)};\\nconst int kepler1_variable_count = 4;","function_name":"kepler1","graph_name_base":"kepler1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.50e+03</td><td>2.06e+04</td><td>1.87e+04</td><td><b><i>5.56e+02</i></b></td><td>1.01e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.68e+03</td><td>2.44e+04</td><td>5.12e+03</td><td><b><i>1.04e+03</i></b></td><td>2.38e+03</td><td>7.70e+03</td><td>7.70e+03</td><td>7.70e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.23e+03</td><td>2.98e+03</td><td>8.19e+02</td><td><b><i>5.24e+02</i></b></td><td>8.96e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.4","expr":"(1.0 - cos(X0)) / sin(X0)","num_variable":"1","file_name":"NMSE_example_3_4.cpp","code":"// FPBench NMSE example 3.4\\ntemplate <class T>\\ninline T NMSE_example_3_4(const std::vector<T> &value_array)\\n{\\n\\treturn (1.0 - cos(value_array[0])) / sin(value_array[0]);\\n}\\nstd::string print_NMSE_example_3_4(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((1) - cos(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) / sin(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_example_3_4(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_4_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_example_3_4_variable_count = 1;","function_name":"NMSE_example_3_4","graph_name_base":"NMSE example 3.4","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.97e+02</td><td>1.17e+04</td><td>1.96e+03</td><td><b><i>4.20e+02</i></b></td><td>4.91e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.63e+02</td><td>1.95e+04</td><td><b><i>4.45e+02</i></b></td><td>4.88e+02</td><td>5.88e+02</td><td>7.68e+03</td><td>7.66e+03</td><td>7.61e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.89e+02</td><td>2.09e+03</td><td><b><i>4.97e+02</i></b></td><td>5.23e+02</td><td>5.99e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 4","expr":"(((X5 - X2) * (X0 + X0) - X5 + X0) * (((X1 - (X4) * (X3)) * (X2 - X1 - (X5) / (X2))) / (X0 - X1 - (X3) / (X5) - (X4) * (X0) + X2))) * (((X3 + X1 - ((X1) / (X2)) * (X3)) / (X4)) * ((X4 - X3) * ((X5) / (X3)) - X2 + X5 + (X1) / (X0) + (X4 + X5 + (X1) * (X0)) / ((X4) * ((X4) * (X2)))))","num_variable":"6","file_name":"expr4.cpp","code":"// Arithmetic expression 4\\ntemplate <class T>\\ninline T expr4(const std::vector<T> &value_array)\\n{\\n    return (((value_array[5] - value_array[2]) * (value_array[0] + value_array[0]) - value_array[5] + value_array[0]) * (((value_array[1] - (value_array[4]) * (value_array[3])) * (value_array[2] - value_array[1] - (value_array[5]) / (value_array[2]))) / (value_array[0] - value_array[1] - (value_array[3]) / (value_array[5]) - (value_array[4]) * (value_array[0]) + value_array[2]))) * (((value_array[3] + value_array[1] - ((value_array[1]) / (value_array[2])) * (value_array[3])) / (value_array[4])) * ((value_array[4] - value_array[3]) * ((value_array[5]) / (value_array[3])) - value_array[2] + value_array[5] + (value_array[1]) / (value_array[0]) + (value_array[4] + value_array[5] + (value_array[1]) * (value_array[0])) / ((value_array[4]) * ((value_array[4]) * (value_array[2])))));\\n}\\nstd::string print_expr4(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[5]) + \\"-\\" + rational_to_string(value_array[2]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"+\\" + rational_to_string(value_array[0]) + \\")\\" + \\"-\\" + rational_to_string(value_array[5]) + \\"+\\" + rational_to_string(value_array[0]) + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\"-\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[2]) + \\"-\\" + rational_to_string(value_array[1]) + \\"-\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[1]) + \\"-\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"-\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"+\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[3]) + \\"+\\" + rational_to_string(value_array[1]) + \\"-\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\"-\\" + rational_to_string(value_array[3]) + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\"-\\" + rational_to_string(value_array[2]) + \\"+\\" + rational_to_string(value_array[5]) + \\"+\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"+\\" + \\"(\\" + rational_to_string(value_array[4]) + \\"+\\" + rational_to_string(value_array[5]) + \\"+\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\";\\n}\\nbool check_input_expr4(const std::vector<double> &value_array)\\n{\\n    if (value_array[2] == 0)\\n        return false;\\n    if (value_array[5] == 0)\\n        return false;\\n    if (value_array[0] - value_array[1] - (value_array[3]) / (value_array[5]) - (value_array[4]) * (value_array[0]) + value_array[2] == 0)\\n        return false;\\n    if (value_array[4] == 0)\\n        return false;\\n    if (value_array[3] == 0)\\n        return false;\\n    if (value_array[0] == 0)\\n        return false;\\n    if ((value_array[4]) * ((value_array[4]) * (value_array[2])) == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr4_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr4_variable_count = 6;","function_name":"expr4","graph_name_base":"ARITHMETIC EXPRESSION 4","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.06e+03</td><td>4.55e+04</td><td>4.01e+04</td><td><b><i>1.19e+03</i></b></td><td>1.79e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.76e+03</td><td>3.74e+04</td><td>1.16e+04</td><td><b><i>2.32e+03</i></b></td><td>4.25e+03</td><td>1.39e+04</td><td>1.39e+04</td><td>1.39e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.57e+03</td><td>4.86e+03</td><td>1.60e+03</td><td><b><i>1.10e+03</i></b></td><td>1.71e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 6","expr":"((X5) / (((X6) * (X4) - X2 - X7) / (((X4) * (X2)) * (X6 + X3)) + X0 + X0 - X5 - X3 + X7)) * (X1)","num_variable":"8","file_name":"expr6.cpp","code":"// Arithmetic expression 6\\ntemplate <class T>\\ninline T expr6(const std::vector<T> &value_array)\\n{\\n    return ((value_array[5]) / (((value_array[6]) * (value_array[4]) - value_array[2] - value_array[7]) / (((value_array[4]) * (value_array[2])) * (value_array[6] + value_array[3])) + value_array[0] + value_array[0] - value_array[5] - value_array[3] + value_array[7])) * (value_array[1]);\\n}\\nstd::string print_expr6(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"(\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"-\\" + rational_to_string(value_array[2]) + \\"-\\" + rational_to_string(value_array[7]) + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"+\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\"+\\" + rational_to_string(value_array[0]) + \\"+\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[5]) + \\"-\\" + rational_to_string(value_array[3]) + \\"+\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\";\\n}\\nbool check_input_expr6(const std::vector<double> &value_array)\\n{\\n    if (((value_array[4]) * (value_array[2])) * (value_array[6] + value_array[3]) == 0)\\n        return false;\\n    if (((value_array[6]) * (value_array[4]) - value_array[2] - value_array[7]) / (((value_array[4]) * (value_array[2])) * (value_array[6] + value_array[3])) + value_array[0] + value_array[0] - value_array[5] - value_array[3] + value_array[7] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr6_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr6_variable_count = 8;","function_name":"expr6","graph_name_base":"ARITHMETIC EXPRESSION 6","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.19e+03</td><td>1.50e+04</td><td>1.37e+04</td><td><b><i>4.37e+02</i></b></td><td>7.96e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.28e+03</td><td>2.29e+04</td><td>3.14e+03</td><td><b><i>7.22e+02</i></b></td><td>1.20e+03</td><td>4.75e+03</td><td>4.75e+03</td><td>4.75e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.15e+03</td><td>1.61e+03</td><td>5.06e+02</td><td><b><i>3.75e+02</i></b></td><td>6.42e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"sin","expr":"sin(X0)","num_variable":"1","file_name":"sin.cpp","code":"// sin\\ntemplate <class T>\\ninline T sin(const std::vector<T> &value_array)\\n{\\n    return sin(value_array[0]);\\n}\\nstd::string print_sin(const std::vector<gmp::Rational> &value_array)\\n{\\n    return \\"sin\\" + rational_to_string(value_array[0]);\\n}\\nbool check_input_sin(const std::vector<double> &value_array)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sin_range = {std::uniform_real_distribution<double>(0, 41629395862109680461101929914152.0 / 53004193035072394913113926582208.0)};\\nconst int sin_variable_count = 1;","function_name":"sin","graph_name_base":"SIN","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.94e+02</td><td>4.67e+03</td><td>1.82e+02</td><td>1.81e+02</td><td><b><i>1.80e+02</i></b></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.02e+02</td><td>6.40e+03</td><td><b><i>1.72e+02</i></b></td><td>1.73e+02</td><td>1.73e+02</td><td>2.99e+03</td><td>2.97e+03</td><td>3.00e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.79e+02</td><td>8.16e+02</td><td>1.78e+02</td><td>1.78e+02</td><td><b><i>1.77e+02</i></b></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.6","expr":"(1.0 / sqrt(X0)) - (1.0 / sqrt(X0 + 1.0))","num_variable":"1","file_name":"NMSE_example_3_6.cpp","code":"// FPBench NMSE example 3.6\\ntemplate <class T>\\ninline T NMSE_example_3_6(const std::vector<T> &value_array)\\n{\\n\\treturn (1.0 / sqrt(value_array[0])) - (1.0 / sqrt(value_array[0] + 1.0));\\n}\\nstd::string print_NMSE_example_3_6(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((1) / sqrt(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) - ((1) / sqrt(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1)))\\";\\n}\\nbool check_input_NMSE_example_3_6(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_6_range = {std::uniform_real_distribution<double>(0, RAND_MAX)};\\nconst int NMSE_example_3_6_variable_count = 1;","function_name":"NMSE_example_3_6","graph_name_base":"NMSE example 3.6","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.01e+03</td><td>6.78e+03</td><td>3.01e+03</td><td><b><i>2.36e+02</i></b></td><td>3.59e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.00e+02</td><td>6.09e+03</td><td>1.06e+03</td><td><b><i>3.42e+02</i></b></td><td>4.32e+02</td><td>1.65e+03</td><td>1.65e+03</td><td>1.65e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.09e+02</td><td>7.60e+02</td><td>2.88e+02</td><td><b><i>2.62e+02</i></b></td><td>3.28e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench carthesianToPolar, theta","expr":"(atan(X1 / X0)) * (180.0 / (3.14159265359))","num_variable":"2","file_name":"carthesianToPolar_theta.cpp","code":"// FPBench carthesianToPolar, theta\\ntemplate <class T>\\ninline T carthesianToPolar_theta(const std::vector<T> &value_array)\\n{\\n\\treturn (atan(value_array[1] / value_array[0])) * (180.0 / (3.14159265359));\\n}\\nstd::string print_carthesianToPolar_theta(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(atan(\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" / \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * ((180) / ((314159265359/100000000000)))\\";\\n}\\nbool check_input_carthesianToPolar_theta(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 100.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 100.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> carthesianToPolar_theta_range = {std::uniform_real_distribution<double>(1.0, 100.0), std::uniform_real_distribution<double>(1.0, 100.0)};\\nconst int carthesianToPolar_theta_variable_count = 2;","function_name":"carthesianToPolar_theta","graph_name_base":"carthesianToPolar, theta","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.13e+02</td><td>4.00e+03</td><td>2.14e+03</td><td><b><i>3.12e+02</i></b></td><td>3.36e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.43e+02</td><td>1.77e+03</td><td><b><i>2.58e+02</i></b></td><td>3.03e+02</td><td>3.18e+02</td><td>1.08e+03</td><td>1.08e+03</td><td>1.08e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.69e+02</td><td>7.01e+02</td><td><b><i>3.41e+02</i></b></td><td>3.56e+02</td><td>3.79e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 5","expr":"sin(cos(sin(cos(X2))) + ((X3) / (X0)) / ((X3) / (X1)) - X1 - sqrt(cos(cos(X6))) + X0) - (cos(sqrt((X4) / (X7)) + sqrt((X2) * (X5)) - X7)) * (sin((cos(sin(X6))) * (X5)) + sin((sin(X0 - X7)) / (X6 - X4)))","num_variable":"8","file_name":"extra_function5.cpp","code":"// Composite expression 5\\ntemplate <class T>\\ninline T extra_function5(const std::vector<T> &value_array)\\n{\\n    return sin(cos(sin(cos(value_array[2]))) + ((value_array[3]) / (value_array[0])) / ((value_array[3]) / (value_array[1])) - value_array[1] - sqrt(cos(cos(value_array[6]))) + value_array[0]) - (cos(sqrt((value_array[4]) / (value_array[7])) + sqrt((value_array[2]) * (value_array[5])) - value_array[7])) * (sin((cos(sin(value_array[6]))) * (value_array[5])) + sin((sin(value_array[0] - value_array[7])) / (value_array[6] - value_array[4])));\\n}\\nstd::string print_extra_function5(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"sin\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\"+\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\"-\\" + rational_to_string(value_array[1]) + \\"-\\" + \\"Sqrt\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\")\\" + \\"+\\" + rational_to_string(value_array[0]) + \\")\\" + \\"-\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\"+\\" + \\"Sqrt\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\"-\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\"+\\" + \\"sin\\" + \\"(\\" + \\"(\\" + \\"sin\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"-\\" + rational_to_string(value_array[4]) + \\")\\" + \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function5(const std::vector<double> &value_array)\\n{\\n    if (value_array[0] == 0)\\n        return false;\\n    if (value_array[1] == 0)\\n        return false;\\n    if ((value_array[3]) / (value_array[1]) == 0)\\n        return false;\\n    if (cos(cos(value_array[6])) < 0)\\n        return false;\\n    if (value_array[7] == 0)\\n        return false;\\n    if ((value_array[4]) / (value_array[7]) < 0)\\n        return false;\\n    if ((value_array[2]) * (value_array[5]) < 0)\\n        return false;\\n    if (value_array[6] - value_array[4] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function5_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int extra_function5_variable_count = 8;","function_name":"extra_function5","graph_name_base":"RANDOM EXPRESSION 5","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>7.15e+03</td><td>8.05e+04</td><td>1.75e+04</td><td><b><i>4.25e+03</i></b></td><td>4.63e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>5.77e+03</td><td>1.17e+05</td><td>9.91e+03</td><td><b><i>5.18e+03</i></b></td><td>6.12e+03</td><td>3.96e+04</td><td>3.95e+04</td><td>3.94e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.16e+03</td><td>1.22e+04</td><td>4.34e+03</td><td><b><i>4.22e+03</i></b></td><td>4.57e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench sqroot","expr":"(((1.0 + (0.5 * X0)) - ((0.125 * X0) * X0)) + (((0.0625 * X0) * X0) * X0)) - ((((0.0390625 * X0) * X0) * X0) * X0)","num_variable":"1","file_name":"sqroot.cpp","code":"// FPBench sqroot\\ntemplate <class T>\\ninline T sqroot(const std::vector<T> &value_array)\\n{\\n\\treturn (((1.0 + (0.5 * value_array[0])) - ((0.125 * value_array[0]) * value_array[0])) + (((0.0625 * value_array[0]) * value_array[0]) * value_array[0])) - ((((0.0390625 * value_array[0]) * value_array[0]) * value_array[0]) * value_array[0]);\\n}\\nstd::string print_sqroot(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((((1) + ((1/2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) - (((1/8) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) + ((((1/16) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) - (((((5/128) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_sqroot(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sqroot_range = {std::uniform_real_distribution<double>(0.0, 1.0)};\\nconst int sqroot_variable_count = 1;","function_name":"sqroot","graph_name_base":"sqroot","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.09e+03</td><td>1.59e+04</td><td>1.14e+04</td><td><b><i>3.31e+02</i></b></td><td>5.70e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>9.59e+02</td><td>1.53e+04</td><td>2.56e+03</td><td><b><i>6.84e+02</i></b></td><td>1.46e+03</td><td>4.65e+03</td><td>4.65e+03</td><td>4.65e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.46e+03</td><td>1.97e+03</td><td>5.76e+02</td><td><b><i>4.65e+02</i></b></td><td>6.53e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Composite expression 4","expr":"sin(sin(((X7) / (X6) + (X3) / (X5)) * (((X1) * (X4)) / (X0))) - cos(sqrt(cos(cos(X2))))) + sqrt((sqrt(sqrt(sqrt(X6 + X5)))) / (sqrt(X2)))","num_variable":"8","file_name":"extra_function4.cpp","code":"// Composite expression 4\\ntemplate <class T>\\ninline T extra_function4(const std::vector<T> &value_array)\\n{\\n    return sin(sin(((value_array[7]) / (value_array[6]) + (value_array[3]) / (value_array[5])) * (((value_array[1]) * (value_array[4])) / (value_array[0]))) - cos(sqrt(cos(cos(value_array[2]))))) + sqrt((sqrt(sqrt(sqrt(value_array[6] + value_array[5])))) / (sqrt(value_array[2])));\\n}\\nstd::string print_extra_function4(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"sin\\" + \\"(\\" + \\"sin\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\"+\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\")\\" + \\")\\" + \\"-\\" + \\"cos\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"cos\\" + \\"(\\" + \\"cos\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"+\\" + \\"Sqrt\\" + \\"(\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[6]) + \\"+\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\" + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + \\"Sqrt\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\")\\";\\n}\\nbool check_input_extra_function4(const std::vector<double> &value_array)\\n{\\n    if (value_array[6] == 0)\\n        return false;\\n    if (value_array[5] == 0)\\n        return false;\\n    if (value_array[0] == 0)\\n        return false;\\n    if (cos(cos(value_array[2])) < 0)\\n        return false;\\n    if (value_array[6] + value_array[5] < 0)\\n        return false;\\n    if (value_array[2] < 0)\\n        return false;\\n    if (sqrt(value_array[2]) == 0)\\n        return false;\\n    if ((sqrt(sqrt(sqrt(value_array[6] + value_array[5])))) / (sqrt(value_array[2])) < 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> extra_function4_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(0, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int extra_function4_variable_count = 8;","function_name":"extra_function4","graph_name_base":"RANDOM EXPRESSION 4","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.33e+03</td><td>4.16e+04</td><td>1.03e+04</td><td><b><i>2.39e+03</i></b></td><td>2.61e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.12e+03</td><td>5.89e+04</td><td>4.78e+03</td><td><b><i>3.11e+03</i></b></td><td>3.60e+03</td><td>2.09e+04</td><td>2.08e+04</td><td>2.08e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.76e+03</td><td>5.73e+03</td><td>2.19e+03</td><td><b><i>2.12e+03</i></b></td><td>2.31e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 10","expr":"X4 + (X7 + X2 + ((X3) * (X0) - (X4) * (X7)) / (X8 + X8 + X6)) * (((X0 - X3 - X6 + (X5) / (X1) - (X2) / (X2)) / (X1)) / (X5))","num_variable":"9","file_name":"expr10.cpp","code":"// Arithmetic expression 10\\ntemplate <class T>\\ninline T expr10(const std::vector<T> &value_array)\\n{\\n    return value_array[4] + (value_array[7] + value_array[2] + ((value_array[3]) * (value_array[0]) - (value_array[4]) * (value_array[7])) / (value_array[8] + value_array[8] + value_array[6])) * (((value_array[0] - value_array[3] - value_array[6] + (value_array[5]) / (value_array[1]) - (value_array[2]) / (value_array[2])) / (value_array[1])) / (value_array[5]));\\n}\\nstd::string print_expr10(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + rational_to_string(value_array[4]) + \\"+\\" + \\"(\\" + rational_to_string(value_array[7]) + \\"+\\" + rational_to_string(value_array[2]) + \\"+\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[0]) + \\")\\" + \\"-\\" + \\"(\\" + rational_to_string(value_array[4]) + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[7]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[8]) + \\"+\\" + rational_to_string(value_array[8]) + \\"+\\" + rational_to_string(value_array[6]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[3]) + \\"-\\" + rational_to_string(value_array[6]) + \\"+\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"-\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[5]) + \\")\\" + \\")\\";\\n}\\nbool check_input_expr10(const std::vector<double> &value_array)\\n{\\n    if (value_array[8] + value_array[8] + value_array[6] == 0)\\n        return false;\\n    if (value_array[1] == 0)\\n        return false;\\n    if (value_array[2] == 0)\\n        return false;\\n    if (value_array[5] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr10_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr10_variable_count = 9;","function_name":"expr10","graph_name_base":"ARITHMETIC EXPRESSION 10","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.78e+03</td><td>1.59e+04</td><td>1.55e+04</td><td><b><i>5.12e+02</i></b></td><td>8.85e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.61e+03</td><td>1.71e+04</td><td>4.25e+03</td><td><b><i>1.00e+03</i></b></td><td>1.92e+03</td><td>6.15e+03</td><td>6.15e+03</td><td>6.15e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.56e+03</td><td>2.17e+03</td><td>7.14e+02</td><td><b><i>5.03e+02</i></b></td><td>8.14e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench kepler2","expr":"(((((((X0 * X3) * (((((-X0 + X1) + X2) - X3) + X4) + X5)) + ((X1 * X4) * (((((X0 - X1) + X2) + X3) - X4) + X5))) + ((X2 * X5) * (((((X0 + X1) - X2) + X3) + X4) - X5))) - ((X1 * X2) * X3)) - ((X0 * X2) * X4)) - ((X0 * X1) * X5)) - ((X3 * X4) * X5)","num_variable":"6","file_name":"kepler2.cpp","code":"// FPBench kepler2\\ntemplate <class T>\\ninline T kepler2(const std::vector<T> &value_array)\\n{\\n\\treturn (((((((value_array[0] * value_array[3]) * (((((-value_array[0] + value_array[1]) + value_array[2]) - value_array[3]) + value_array[4]) + value_array[5])) + ((value_array[1] * value_array[4]) * (((((value_array[0] - value_array[1]) + value_array[2]) + value_array[3]) - value_array[4]) + value_array[5]))) + ((value_array[2] * value_array[5]) * (((((value_array[0] + value_array[1]) - value_array[2]) + value_array[3]) + value_array[4]) - value_array[5]))) - ((value_array[1] * value_array[2]) * value_array[3])) - ((value_array[0] * value_array[2]) * value_array[4])) - ((value_array[0] * value_array[1]) * value_array[5])) - ((value_array[3] * value_array[4]) * value_array[5]);\\n}\\nstd::string print_kepler2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") * (((((-\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") * (((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\"))) + ((\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\") * (((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\"))) - ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) - ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\")) - ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) - ((\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")\\";\\n}\\nbool check_input_kepler2(const std::vector<double> &v)\\n{\\n    if (4.0 > v[0])\\n        return false;\\n    if (v[0] > 6.36)\\n        return false;\\n    if (4.0 > v[1])\\n        return false;\\n    if (v[1] > 6.36)\\n        return false;\\n    if (4.0 > v[2])\\n        return false;\\n    if (v[2] > 6.36)\\n        return false;\\n    if (4.0 > v[3])\\n        return false;\\n    if (v[3] > 6.36)\\n        return false;\\n    if (4.0 > v[4])\\n        return false;\\n    if (v[4] > 6.36)\\n        return false;\\n    if (4.0 > v[5])\\n        return false;\\n    if (v[5] > 6.36)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> kepler2_range = {std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36), std::uniform_real_distribution<double>(4.0, 6.36)};\\nconst int kepler2_variable_count = 6;","function_name":"kepler2","graph_name_base":"kepler2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>5.37e+03</td><td>3.12e+04</td><td>2.93e+04</td><td><b><i>8.43e+02</i></b></td><td>1.60e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.38e+03</td><td>3.94e+04</td><td>9.26e+03</td><td><b><i>1.55e+03</i></b></td><td>3.73e+03</td><td>1.17e+04</td><td>1.17e+04</td><td>1.17e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.35e+03</td><td>4.47e+03</td><td>1.21e+03</td><td><b><i>8.29e+02</i></b></td><td>1.46e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"cos","expr":"cos(X0)","num_variable":"1","file_name":"cos.cpp","code":"// cos\\ntemplate <class T>\\ninline T cos(const std::vector<T> &value_array)\\n{\\n    return cos(value_array[0]);\\n}\\nstd::string print_cos(const std::vector<gmp::Rational> &value_array)\\n{\\n    return \\"cos\\" + rational_to_string(value_array[0]);\\n}\\nbool check_input_cos(const std::vector<double> &value_array)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sin_range = {std::uniform_real_distribution<double>(0, 41629395862109680461101929914152.0 / 53004193035072394913113926582208.0)};\\nconst int sin_variable_count = 1;","function_name":"cos","graph_name_base":"COS","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.78e+02</td><td>4.54e+03</td><td>1.63e+02</td><td>1.63e+02</td><td><b><i>1.63e+02</i></b></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.90e+02</td><td>5.73e+03</td><td>1.69e+02</td><td><b><i>1.68e+02</i></b></td><td>1.69e+02</td><td>3.28e+03</td><td>3.30e+03</td><td>3.28e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.70e+02</td><td>7.25e+02</td><td>1.69e+02</td><td>1.69e+02</td><td><b><i>1.69e+02</i></b></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE example 3.7","expr":"exp(X0) - 1.0","num_variable":"1","file_name":"NMSE_example_3_7.cpp","code":"// FPBench NMSE example 3.7\\ntemplate <class T>\\ninline T NMSE_example_3_7(const std::vector<T> &value_array)\\n{\\n\\treturn exp(value_array[0]) - 1.0;\\n}\\nstd::string print_NMSE_example_3_7(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"exp(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - (1)\\";\\n}\\nbool check_input_NMSE_example_3_7(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_example_3_7_range = {std::uniform_real_distribution<double>(-700, 700)};\\nconst int NMSE_example_3_7_variable_count = 1;","function_name":"NMSE_example_3_7","graph_name_base":"NMSE example 3.7","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td><b><i>2.92e+02</i></b></td><td>3.06e+03</td><td>1.48e+03</td><td>3.01e+02</td><td>3.58e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.69e+02</td><td>8.65e+02</td><td>1.73e+02</td><td><b><i>1.69e+02</i></b></td><td>1.75e+02</td><td>4.76e+02</td><td>4.77e+02</td><td>4.77e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.82e+02</td><td>3.56e+02</td><td>2.06e+02</td><td><b><i>1.89e+02</i></b></td><td>1.94e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"Arithmetic expression 7","expr":"(X2) / (((X1) / (X3 + X4) + X0 - X2 + (X1) / (X3)) * (X6) + X5)","num_variable":"7","file_name":"expr7.cpp","code":"// Arithmetic expression 7\\ntemplate <class T>\\ninline T expr7(const std::vector<T> &value_array)\\n{\\n    return (value_array[2]) / (((value_array[1]) / (value_array[3] + value_array[4]) + value_array[0] - value_array[2] + (value_array[1]) / (value_array[3])) * (value_array[6]) + value_array[5]);\\n}\\nstd::string print_expr7(const std::vector<gmp::Rational> &value_array)\\n{\\n    return std::string() + \\"(\\" + rational_to_string(value_array[2]) + \\")\\" + \\"/\\" + \\"(\\" + \\"(\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[3]) + \\"+\\" + rational_to_string(value_array[4]) + \\")\\" + \\"+\\" + rational_to_string(value_array[0]) + \\"-\\" + rational_to_string(value_array[2]) + \\"+\\" + \\"(\\" + rational_to_string(value_array[1]) + \\")\\" + \\"/\\" + \\"(\\" + rational_to_string(value_array[3]) + \\")\\" + \\")\\" + \\"*\\" + \\"(\\" + rational_to_string(value_array[6]) + \\")\\" + \\"+\\" + rational_to_string(value_array[5]) + \\")\\";\\n}\\nbool check_input_expr7(const std::vector<double> &value_array)\\n{\\n    if (value_array[3] + value_array[4] == 0)\\n        return false;\\n    if (value_array[3] == 0)\\n        return false;\\n    if (((value_array[1]) / (value_array[3] + value_array[4]) + value_array[0] - value_array[2] + (value_array[1]) / (value_array[3])) * (value_array[6]) + value_array[5] == 0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> expr7_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int expr7_variable_count = 7;","function_name":"expr7","graph_name_base":"ARITHMETIC EXPRESSION 7","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.42e+03</td><td>9.62e+03</td><td>9.09e+03</td><td><b><i>2.81e+02</i></b></td><td>4.88e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.67e+02</td><td>8.83e+03</td><td>1.70e+03</td><td><b><i>4.97e+02</i></b></td><td>7.36e+02</td><td>3.02e+03</td><td>3.02e+03</td><td>3.02e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.41e+02</td><td>1.04e+03</td><td>3.65e+02</td><td><b><i>2.45e+02</i></b></td><td>4.12e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench himmilbeau","expr":"((((X0 * X0) + X1) - 11.0) * (((X0 * X0) + X1) - 11.0)) + (((X0 + (X1 * X1)) - 7.0) * ((X0 + (X1 * X1)) - 7.0))","num_variable":"2","file_name":"himmilbeau.cpp","code":"// FPBench himmilbeau\\ntemplate <class T>\\ninline T himmilbeau(const std::vector<T> &value_array)\\n{\\n\\treturn ((((value_array[0] * value_array[0]) + value_array[1]) - 11.0) * (((value_array[0] * value_array[0]) + value_array[1]) - 11.0)) + (((value_array[0] + (value_array[1] * value_array[1])) - 7.0) * ((value_array[0] + (value_array[1] * value_array[1])) - 7.0));\\n}\\nstd::string print_himmilbeau(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (11)) * (((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (11))) + (((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - (7)) * ((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) - (7)))\\";\\n}\\nbool check_input_himmilbeau(const std::vector<double> &v)\\n{\\n    if (-5.0 > v[0])\\n        return false;\\n    if (v[0] > 5.0)\\n        return false;\\n    if (-5.0 > v[1])\\n        return false;\\n    if (v[1] > 5.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> himmilbeau_range = {std::uniform_real_distribution<double>(-5.0, 5.0), std::uniform_real_distribution<double>(-5.0, 5.0)};\\nconst int himmilbeau_variable_count = 2;","function_name":"himmilbeau","graph_name_base":"himmilbeau","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.27e+03</td><td>1.47e+04</td><td>1.24e+04</td><td><b><i>3.64e+02</i></b></td><td>6.80e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.12e+03</td><td>1.41e+04</td><td>2.95e+03</td><td><b><i>7.01e+02</i></b></td><td>1.56e+03</td><td>4.99e+03</td><td>4.99e+03</td><td>4.99e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.41e+03</td><td>1.86e+03</td><td>5.58e+02</td><td><b><i>3.94e+02</i></b></td><td>6.16e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench sphere","expr":"X0 + ((X1 * (sin(X2))) * (cos(X3)))","num_variable":"4","file_name":"sphere.cpp","code":"// FPBench sphere\\ntemplate <class T>\\ninline T sphere(const std::vector<T> &value_array)\\n{\\n\\treturn value_array[0] + ((value_array[1] * (sin(value_array[2]))) * (cos(value_array[3])));\\n}\\nstd::string print_sphere(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + ((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * (sin(\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\"))) * (cos(\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")))\\";\\n}\\nbool check_input_sphere(const std::vector<double> &v)\\n{\\n    if (-10.0 > v[0])\\n        return false;\\n    if (v[0] > 10.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 10.0)\\n        return false;\\n    if (-1.570796 > v[2])\\n        return false;\\n    if (v[2] > 1.570796)\\n        return false;\\n    if (-3.14159265 > v[3])\\n        return false;\\n    if (v[3] > 3.14159265)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sphere_range = {std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(0.0, 10.0), std::uniform_real_distribution<double>(-1.570796, 1.570796), std::uniform_real_distribution<double>(-3.14159265, 3.14159265)};\\nconst int sphere_variable_count = 4;","function_name":"sphere","graph_name_base":"sphere","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>8.09e+02</td><td>1.33e+04</td><td>2.77e+03</td><td><b><i>4.75e+02</i></b></td><td>5.40e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.14e+02</td><td>2.12e+04</td><td>7.47e+02</td><td><b><i>4.24e+02</i></b></td><td>6.44e+02</td><td>6.04e+03</td><td>6.04e+03</td><td>6.06e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>8.67e+02</td><td>2.38e+03</td><td><b><i>5.26e+02</i></b></td><td>5.90e+02</td><td>6.74e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench Complex sine and cosine","expr":"(0.5 * sin(X0)) * (exp(-X1) - exp(X1))","num_variable":"2","file_name":"Complex_sine_and_cosine.cpp","code":"// FPBench Complex sine and cosine\\ntemplate <class T>\\ninline T Complex_sine_and_cosine(const std::vector<T> &value_array)\\n{\\n\\treturn (0.5 * sin(value_array[0])) * (exp(-value_array[1]) - exp(value_array[1]));\\n}\\nstd::string print_Complex_sine_and_cosine(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((1/2) * sin(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * (exp(-\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - exp(\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_Complex_sine_and_cosine(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> Complex_sine_and_cosine_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-700, 700)};\\nconst int Complex_sine_and_cosine_variable_count = 2;","function_name":"Complex_sine_and_cosine","graph_name_base":"Complex sine and cosine","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>9.30e+02</td><td>1.12e+04</td><td>3.74e+03</td><td><b><i>9.27e+02</i></b></td><td>9.79e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>8.64e+02</td><td>1.76e+04</td><td>1.33e+03</td><td><b><i>6.37e+02</i></b></td><td>8.45e+02</td><td>4.81e+03</td><td>4.80e+03</td><td>4.80e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>9.19e+02</td><td>1.67e+03</td><td><b><i>6.28e+02</i></b></td><td>7.21e+02</td><td>7.72e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench sine","expr":"((X0 - (((X0 * X0) * X0) / 6.0)) + (((((X0 * X0) * X0) * X0) * X0) / 120.0)) - (((((((X0 * X0) * X0) * X0) * X0) * X0) * X0) / 5040.0)","num_variable":"1","file_name":"sine.cpp","code":"// FPBench sine\\ntemplate <class T>\\ninline T sine(const std::vector<T> &value_array)\\n{\\n\\treturn ((value_array[0] - (((value_array[0] * value_array[0]) * value_array[0]) / 6.0)) + (((((value_array[0] * value_array[0]) * value_array[0]) * value_array[0]) * value_array[0]) / 120.0)) - (((((((value_array[0] * value_array[0]) * value_array[0]) * value_array[0]) * value_array[0]) * value_array[0]) * value_array[0]) / 5040.0);\\n}\\nstd::string print_sine(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" - (((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / (6))) + (((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / (120))) - (((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / (5040))\\";\\n}\\nbool check_input_sine(const std::vector<double> &v)\\n{\\n    if (-1.57079632679 >= v[0])\\n        return false;\\n    if (v[0] >= 1.57079632679)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sine_range = {std::uniform_real_distribution<double>(-1.57079632679, 1.57079632679)};\\nconst int sine_variable_count = 1;","function_name":"sine","graph_name_base":"sine","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.81e+03</td><td>1.86e+04</td><td>1.79e+04</td><td><b><i>5.33e+02</i></b></td><td>9.24e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.38e+03</td><td>2.06e+04</td><td>4.09e+03</td><td><b><i>1.16e+03</i></b></td><td>2.15e+03</td><td>6.99e+03</td><td>6.98e+03</td><td>6.98e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.56e+03</td><td>2.15e+03</td><td>6.89e+02</td><td><b><i>5.38e+02</i></b></td><td>8.71e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench test02_sum8","expr":"((((((X0 + X1) + X2) + X3) + X4) + X5) + X6) + X7","num_variable":"8","file_name":"test02_sum8.cpp","code":"// FPBench test02_sum8\\ntemplate <class T>\\ninline T test02_sum8(const std::vector<T> &value_array)\\n{\\n\\treturn ((((((value_array[0] + value_array[1]) + value_array[2]) + value_array[3]) + value_array[4]) + value_array[5]) + value_array[6]) + value_array[7];\\n}\\nstd::string print_test02_sum8(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((((((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[6]) + \\")\\" + \\") + \\" + \\"(\\" + rational_to_string(v[7]) + \\")\\";\\n}\\nbool check_input_test02_sum8(const std::vector<double> &v)\\n{\\n    if (1.0 >= v[0])\\n        return false;\\n    if (v[0] >= 2.0)\\n        return false;\\n    if (1.0 >= v[1])\\n        return false;\\n    if (v[1] >= 2.0)\\n        return false;\\n    if (1.0 >= v[2])\\n        return false;\\n    if (v[2] >= 2.0)\\n        return false;\\n    if (1.0 >= v[3])\\n        return false;\\n    if (v[3] >= 2.0)\\n        return false;\\n    if (1.0 >= v[4])\\n        return false;\\n    if (v[4] >= 2.0)\\n        return false;\\n    if (1.0 >= v[5])\\n        return false;\\n    if (v[5] >= 2.0)\\n        return false;\\n    if (1.0 >= v[6])\\n        return false;\\n    if (v[6] >= 2.0)\\n        return false;\\n    if (1.0 >= v[7])\\n        return false;\\n    if (v[7] >= 2.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> test02_sum8_range = {std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0), std::uniform_real_distribution<double>(1.0, 2.0)};\\nconst int test02_sum8_variable_count = 8;","function_name":"test02_sum8","graph_name_base":"test02_sum8","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.08e+03</td><td>7.20e+03</td><td>6.25e+03</td><td><b><i>1.77e+02</i></b></td><td>3.52e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.50e+02</td><td>9.00e+03</td><td>6.39e+02</td><td><b><i>1.44e+02</i></b></td><td>2.16e+02</td><td>2.31e+03</td><td>2.31e+03</td><td>2.31e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.09e+02</td><td>8.80e+02</td><td>2.04e+02</td><td><b><i>1.25e+02</i></b></td><td>2.90e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"multiplication","expr":"X0 * X1","num_variable":"2","file_name":"multiplication.cpp","code":"// multiplication\\ntemplate <class T>\\ninline T multiplication(const std::vector<T> &value_array)\\n{\\n    return value_array[0] * value_array[1];\\n}\\nstd::string print_multiplication(const std::vector<gmp::Rational> &value_array)\\n{\\n    return rational_to_string(value_array[0]) + \\"*\\" + rational_to_string(value_array[1]);\\n}\\nbool check_input_multiplication(const std::vector<double> &value_array)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> multiplication_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int multiplication_variable_count = 2;","function_name":"multiplication","graph_name_base":"MULTIPLICATION","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.19e+02</td><td>1.14e+03</td><td>1.14e+03</td><td><b><i>3.12e+01</i></b></td><td>5.07e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.53e+01</td><td>7.09e+02</td><td><b><i>2.50e+01</i></b></td><td>6.53e+01</td><td>1.01e+02</td><td>3.38e+02</td><td>3.38e+02</td><td>3.38e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>9.34e+01</td><td>1.23e+02</td><td>3.50e+01</td><td>3.68e+01</td><td><b><i>3.47e+01</i></b></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench rigidBody2","expr":"((((((2.0 * X0) * X1) * X2) + ((3.0 * X2) * X2)) - (((X1 * X0) * X1) * X2)) + ((3.0 * X2) * X2)) - X1","num_variable":"3","file_name":"rigidBody2.cpp","code":"// FPBench rigidBody2\\ntemplate <class T>\\ninline T rigidBody2(const std::vector<T> &value_array)\\n{\\n\\treturn ((((((2.0 * value_array[0]) * value_array[1]) * value_array[2]) + ((3.0 * value_array[2]) * value_array[2])) - (((value_array[1] * value_array[0]) * value_array[1]) * value_array[2])) + ((3.0 * value_array[2]) * value_array[2])) - value_array[1];\\n}\\nstd::string print_rigidBody2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((((((2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") + (((3) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) - (((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) + (((3) * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\";\\n}\\nbool check_input_rigidBody2(const std::vector<double> &v)\\n{\\n    if (-15.0 > v[0])\\n        return false;\\n    if (v[0] > 15.0)\\n        return false;\\n    if (-15.0 > v[1])\\n        return false;\\n    if (v[1] > 15.0)\\n        return false;\\n    if (-15.0 > v[2])\\n        return false;\\n    if (v[2] > 15.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> rigidBody2_range = {std::uniform_real_distribution<double>(-15.0, 15.0), std::uniform_real_distribution<double>(-15.0, 15.0), std::uniform_real_distribution<double>(-15.0, 15.0)};\\nconst int rigidBody2_variable_count = 3;","function_name":"rigidBody2","graph_name_base":"rigidBody2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.09e+03</td><td>1.36e+04</td><td>1.15e+04</td><td><b><i>3.87e+02</i></b></td><td>6.54e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.16e+03</td><td>1.73e+04</td><td>2.92e+03</td><td><b><i>7.11e+02</i></b></td><td>1.18e+03</td><td>5.38e+03</td><td>5.37e+03</td><td>5.38e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.15e+03</td><td>1.57e+03</td><td>4.58e+02</td><td><b><i>3.88e+02</i></b></td><td>5.08e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench test04_dqmom9","expr":"0.0 + ((((X3 * (0.0 - X0)) * (-3.0 * ((1.0 * (X6 / X3)) * (X6 / X3)))) * 1.0) + ((((X4 * (0.0 - X1)) * (-3.0 * ((1.0 * (X7 / X4)) * (X7 / X4)))) * 1.0) + ((((X5 * (0.0 - X2)) * (-3.0 * ((1.0 * (X8 / X5)) * (X8 / X5)))) * 1.0) + 0.0)))","num_variable":"9","file_name":"test04_dqmom9.cpp","code":"// FPBench test04_dqmom9\\ntemplate <class T>\\ninline T test04_dqmom9(const std::vector<T> &value_array)\\n{\\n\\treturn 0.0 + ((((value_array[3] * (0.0 - value_array[0])) * (-3.0 * ((1.0 * (value_array[6] / value_array[3])) * (value_array[6] / value_array[3])))) * 1.0) + ((((value_array[4] * (0.0 - value_array[1])) * (-3.0 * ((1.0 * (value_array[7] / value_array[4])) * (value_array[7] / value_array[4])))) * 1.0) + ((((value_array[5] * (0.0 - value_array[2])) * (-3.0 * ((1.0 * (value_array[8] / value_array[5])) * (value_array[8] / value_array[5])))) * 1.0) + 0.0)));\\n}\\nstd::string print_test04_dqmom9(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(0) + ((((\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" * ((0) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")) * (-(3) * (((1) * (\\" + \\"(\\" + rational_to_string(v[6]) + \\")\\" + \\" / \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) * (\\" + \\"(\\" + rational_to_string(v[6]) + \\")\\" + \\" / \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")))) * (1)) + ((((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * ((0) - \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) * (-(3) * (((1) * (\\" + \\"(\\" + rational_to_string(v[7]) + \\")\\" + \\" / \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\")) * (\\" + \\"(\\" + rational_to_string(v[7]) + \\")\\" + \\" / \\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\")))) * (1)) + ((((\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" * ((0) - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) * (-(3) * (((1) * (\\" + \\"(\\" + rational_to_string(v[8]) + \\")\\" + \\" / \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) * (\\" + \\"(\\" + rational_to_string(v[8]) + \\")\\" + \\" / \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")))) * (1)) + (0))))\\";\\n}\\nbool check_input_test04_dqmom9(const std::vector<double> &v)\\n{\\n    if (-1.0 >= v[0])\\n        return false;\\n    if (v[0] >= 1.0)\\n        return false;\\n    if (-1.0 >= v[1])\\n        return false;\\n    if (v[1] >= 1.0)\\n        return false;\\n    if (-1.0 >= v[2])\\n        return false;\\n    if (v[2] >= 1.0)\\n        return false;\\n    if (1e-05 >= v[3])\\n        return false;\\n    if (v[3] >= 1.0)\\n        return false;\\n    if (1e-05 >= v[4])\\n        return false;\\n    if (v[4] >= 1.0)\\n        return false;\\n    if (1e-05 >= v[5])\\n        return false;\\n    if (v[5] >= 1.0)\\n        return false;\\n    if (1e-05 >= v[6])\\n        return false;\\n    if (v[6] >= 1.0)\\n        return false;\\n    if (1e-05 >= v[7])\\n        return false;\\n    if (v[7] >= 1.0)\\n        return false;\\n    if (1e-05 >= v[8])\\n        return false;\\n    if (v[8] >= 1.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> test04_dqmom9_range = {std::uniform_real_distribution<double>(-1.0, 1.0), std::uniform_real_distribution<double>(-1.0, 1.0), std::uniform_real_distribution<double>(-1.0, 1.0), std::uniform_real_distribution<double>(1e-05, 1.0), std::uniform_real_distribution<double>(1e-05, 1.0), std::uniform_real_distribution<double>(1e-05, 1.0), std::uniform_real_distribution<double>(1e-05, 1.0), std::uniform_real_distribution<double>(1e-05, 1.0), std::uniform_real_distribution<double>(1e-05, 1.0)};\\nconst int test04_dqmom9_variable_count = 9;","function_name":"test04_dqmom9","graph_name_base":"test04_dqmom9","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>4.66e+03</td><td>2.98e+04</td><td>2.78e+04</td><td><b><i>8.32e+02</i></b></td><td>1.38e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.04e+03</td><td>4.14e+04</td><td>9.97e+03</td><td><b><i>1.98e+03</i></b></td><td>3.08e+03</td><td>1.21e+04</td><td>1.21e+04</td><td>1.21e+04</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>2.79e+03</td><td>3.91e+03</td><td>1.19e+03</td><td><b><i>9.89e+02</i></b></td><td>1.48e+03</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench floudas","expr":"X0 + X1","num_variable":"2","file_name":"floudas.cpp","code":"// FPBench floudas\\ntemplate <class T>\\ninline T floudas(const std::vector<T> &value_array)\\n{\\n\\treturn value_array[0] + value_array[1];\\n}\\nstd::string print_floudas(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\";\\n}\\nbool check_input_floudas(const std::vector<double> &v)\\n{\\n    if (0.0 > v[0])\\n        return false;\\n    if (v[0] > 2.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 3.0)\\n        return false;\\n    if ((v[0] + v[1]) > 2)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> floudas_range = {std::uniform_real_distribution<double>(0.0, 2.0), std::uniform_real_distribution<double>(0.0, 3.0)};\\nconst int floudas_variable_count = 2;","function_name":"floudas","graph_name_base":"floudas","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.18e+02</td><td>1.04e+03</td><td>4.13e+02</td><td><b><i>2.67e+01</i></b></td><td>3.28e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.91e+01</td><td>4.05e+02</td><td>1.84e+01</td><td><b><i>3.93e+00</i></b></td><td>6.24e+00</td><td>3.28e+02</td><td>3.26e+02</td><td>3.27e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.75e+01</td><td>1.09e+02</td><td>2.79e+01</td><td><b><i>9.25e+00</i></b></td><td>1.16e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench verhulst","expr":"((4.0) * X0) / (1.0 + (X0 / (1.11)))","num_variable":"1","file_name":"verhulst.cpp","code":"// FPBench verhulst\\ntemplate <class T>\\ninline T verhulst(const std::vector<T> &value_array)\\n{\\n\\treturn ((4.0) * value_array[0]) / (1.0 + (value_array[0] / (1.11)));\\n}\\nstd::string print_verhulst(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(((4)) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") / ((1) + (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / ((111/100))))\\";\\n}\\nbool check_input_verhulst(const std::vector<double> &v)\\n{\\n    if (0.1 > v[0])\\n        return false;\\n    if (v[0] > 0.3)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> verhulst_range = {std::uniform_real_distribution<double>(0.1, 0.3)};\\nconst int verhulst_variable_count = 1;","function_name":"verhulst","graph_name_base":"verhulst","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.02e+02</td><td>4.05e+03</td><td>4.18e+03</td><td><b><i>1.11e+02</i></b></td><td>1.65e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>2.71e+02</td><td>2.92e+03</td><td><b><i>9.10e+01</i></b></td><td>1.20e+02</td><td>1.94e+02</td><td>1.75e+03</td><td>1.75e+03</td><td>1.75e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>3.92e+02</td><td>5.49e+02</td><td>1.85e+02</td><td><b><i>1.64e+02</i></b></td><td>2.07e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench NMSE p42, negative","expr":"(-X1 - sqrt((X1 * X1) - (4.0 * (X0 * X2)))) / (2.0 * X0)","num_variable":"3","file_name":"NMSE_p42_negative.cpp","code":"// FPBench NMSE p42, negative\\ntemplate <class T>\\ninline T NMSE_p42_negative(const std::vector<T> &value_array)\\n{\\n\\treturn (-value_array[1] - sqrt((value_array[1] * value_array[1]) - (4.0 * (value_array[0] * value_array[2])))) / (2.0 * value_array[0]);\\n}\\nstd::string print_NMSE_p42_negative(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(-\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" - sqrt((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - ((4) * (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")))) / ((2) * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\")\\";\\n}\\nbool check_input_NMSE_p42_negative(const std::vector<double> &v)\\n{\\n    if ((v[1] * v[1]) < (4 * (v[0] * v[2])))\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> NMSE_p42_negative_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int NMSE_p42_negative_variable_count = 3;","function_name":"NMSE_p42_negative","graph_name_base":"NMSE p42, negative","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.27e+03</td><td>7.87e+03</td><td>6.24e+03</td><td><b><i>2.78e+02</i></b></td><td>4.39e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>7.00e+02</td><td>9.50e+03</td><td>1.45e+03</td><td><b><i>5.36e+02</i></b></td><td>8.19e+02</td><td>2.67e+03</td><td>2.67e+03</td><td>2.67e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.00e+02</td><td>9.29e+02</td><td>3.46e+02</td><td><b><i>2.71e+02</i></b></td><td>3.85e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench sqrt_add","expr":"1.0 / (sqrt(X0 + 1.0) + sqrt(X0))","num_variable":"1","file_name":"sqrt_add.cpp","code":"// FPBench sqrt_add\\ntemplate <class T>\\ninline T sqrt_add(const std::vector<T> &value_array)\\n{\\n\\treturn 1.0 / (sqrt(value_array[0] + 1.0) + sqrt(value_array[0]));\\n}\\nstd::string print_sqrt_add(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(1) / (sqrt(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + (1)) + sqrt(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_sqrt_add(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 1000.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> sqrt_add_range = {std::uniform_real_distribution<double>(1.0, 1000.0)};\\nconst int sqrt_add_variable_count = 1;","function_name":"sqrt_add","graph_name_base":"sqrt_add","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>8.12e+02</td><td>6.00e+03</td><td>2.85e+03</td><td><b><i>2.02e+02</i></b></td><td>3.07e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>3.99e+02</td><td>5.79e+03</td><td>6.16e+02</td><td><b><i>2.61e+02</i></b></td><td>3.29e+02</td><td>1.95e+03</td><td>1.90e+03</td><td>2.08e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>5.70e+02</td><td>7.03e+02</td><td>2.66e+02</td><td><b><i>2.28e+02</i></b></td><td>2.89e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench rigidBody1","expr":"((-(X0 * X1) - ((2.0 * X1) * X2)) - X0) - X2","num_variable":"3","file_name":"rigidBody1.cpp","code":"// FPBench rigidBody1\\ntemplate <class T>\\ninline T rigidBody1(const std::vector<T> &value_array)\\n{\\n\\treturn ((-(value_array[0] * value_array[1]) - ((2.0 * value_array[1]) * value_array[2])) - value_array[0]) - value_array[2];\\n}\\nstd::string print_rigidBody1(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((-(\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") - (((2) * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\") * \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\")) - \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") - \\" + \\"(\\" + rational_to_string(v[2]) + \\")\\";\\n}\\nbool check_input_rigidBody1(const std::vector<double> &v)\\n{\\n    if (-15.0 > v[0])\\n        return false;\\n    if (v[0] > 15.0)\\n        return false;\\n    if (-15.0 > v[1])\\n        return false;\\n    if (v[1] > 15.0)\\n        return false;\\n    if (-15.0 > v[2])\\n        return false;\\n    if (v[2] > 15.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> rigidBody1_range = {std::uniform_real_distribution<double>(-15.0, 15.0), std::uniform_real_distribution<double>(-15.0, 15.0), std::uniform_real_distribution<double>(-15.0, 15.0)};\\nconst int rigidBody1_variable_count = 3;","function_name":"rigidBody1","graph_name_base":"rigidBody1","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>8.57e+02</td><td>6.09e+03</td><td>3.90e+03</td><td><b><i>8.42e+01</i></b></td><td>2.83e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.72e+02</td><td>5.44e+03</td><td>8.74e+02</td><td><b><i>2.30e+02</i></b></td><td>3.67e+02</td><td>2.26e+03</td><td>2.25e+03</td><td>2.25e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>6.02e+02</td><td>8.37e+02</td><td>2.42e+02</td><td><b><i>1.78e+02</i></b></td><td>2.84e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"exponential","expr":"exp(X0)","num_variable":"1","file_name":"exponential.cpp","code":"// exponential\\ntemplate <class T>\\ninline T exponential(const std::vector<T> &value_array)\\n{\\n    return exp(value_array[0]);\\n}\\nstd::string print_exponential(const std::vector<gmp::Rational> &value_array)\\n{\\n    return \\"Exp\\" + rational_to_string(value_array[0]);\\n}\\nbool check_input_exponential(const std::vector<double> &value_array)\\n{\\n    if (value_array[0] > 700)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> exponential_range = {std::uniform_real_distribution<double>(-700, 700)};\\nconst int exponential_variable_count = 1;","function_name":"exponential","graph_name_base":"EXPONENTIAL","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td><b><i>1.81e+02</i></b></td><td>1.62e+03</td><td>3.14e+02</td><td>3.13e+02</td><td>3.13e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.98e+02</td><td>4.61e+02</td><td>1.44e+02</td><td>1.44e+02</td><td><b><i>1.44e+02</i></b></td><td>1.90e+02</td><td>1.92e+02</td><td>1.93e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.55e+02</td><td>1.95e+02</td><td><b><i>1.53e+02</i></b></td><td>1.54e+02</td><td>1.54e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench x_by_xy","expr":"X0 / (X0 + X1)","num_variable":"2","file_name":"x_by_xy.cpp","code":"// FPBench x_by_xy\\ntemplate <class T>\\ninline T x_by_xy(const std::vector<T> &value_array)\\n{\\n\\treturn value_array[0] / (value_array[0] + value_array[1]);\\n}\\nstd::string print_x_by_xy(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" / (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" + \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")\\";\\n}\\nbool check_input_x_by_xy(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 4.0)\\n        return false;\\n    if (1.0 > v[1])\\n        return false;\\n    if (v[1] > 4.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> x_by_xy_range = {std::uniform_real_distribution<double>(1.0, 4.0), std::uniform_real_distribution<double>(1.0, 4.0)};\\nconst int x_by_xy_variable_count = 2;","function_name":"x_by_xy","graph_name_base":"x_by_xy","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>3.13e+02</td><td>1.95e+03</td><td>1.84e+03</td><td><b><i>5.60e+01</i></b></td><td>7.71e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.50e+02</td><td>8.72e+02</td><td>3.81e+02</td><td><b><i>7.68e+01</i></b></td><td>1.26e+02</td><td>6.58e+02</td><td>6.58e+02</td><td>6.58e+02</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.68e+02</td><td>2.35e+02</td><td>7.69e+01</td><td><b><i>5.85e+01</i></b></td><td>7.13e+01</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench polarToCarthesian, x","expr":"X0 * cos((X1 * ((3.14159265359) / 180.0)))","num_variable":"2","file_name":"polarToCarthesian_x.cpp","code":"// FPBench polarToCarthesian, x\\ntemplate <class T>\\ninline T polarToCarthesian_x(const std::vector<T> &value_array)\\n{\\n\\treturn value_array[0] * cos((value_array[1] * ((3.14159265359) / 180.0)));\\n}\\nstd::string print_polarToCarthesian_x(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * cos((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * (((314159265359/100000000000)) / (180))))\\";\\n}\\nbool check_input_polarToCarthesian_x(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 10.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 360.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> polarToCarthesian_x_range = {std::uniform_real_distribution<double>(1.0, 10.0), std::uniform_real_distribution<double>(0.0, 360.0)};\\nconst int polarToCarthesian_x_variable_count = 2;","function_name":"polarToCarthesian_x","graph_name_base":"polarToCarthesian, x","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.27e+02</td><td>6.32e+03</td><td>2.07e+03</td><td><b><i>3.30e+02</i></b></td><td>3.50e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.65e+02</td><td>8.89e+03</td><td>4.33e+02</td><td><b><i>3.19e+02</i></b></td><td>4.44e+02</td><td>4.81e+03</td><td>4.80e+03</td><td>4.80e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.46e+02</td><td>9.84e+02</td><td><b><i>3.53e+02</i></b></td><td>3.61e+02</td><td>3.82e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench matrixDeterminant2","expr":"((X0 * (X4 * X8)) + ((X6 * (X1 * X5)) + (X2 * (X3 * X7)))) - ((X4 * (X2 * X6)) + ((X8 * (X1 * X3)) + (X0 * (X5 * X7))))","num_variable":"9","file_name":"matrixDeterminant2.cpp","code":"// FPBench matrixDeterminant2\\ntemplate <class T>\\ninline T matrixDeterminant2(const std::vector<T> &value_array)\\n{\\n\\treturn ((value_array[0] * (value_array[4] * value_array[8])) + ((value_array[6] * (value_array[1] * value_array[5])) + (value_array[2] * (value_array[3] * value_array[7])))) - ((value_array[4] * (value_array[2] * value_array[6])) + ((value_array[8] * (value_array[1] * value_array[3])) + (value_array[0] * (value_array[5] * value_array[7]))));\\n}\\nstd::string print_matrixDeterminant2(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[8]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[6]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\")) + (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[7]) + \\")\\" + \\")))) - ((\\" + \\"(\\" + rational_to_string(v[4]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[2]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[6]) + \\")\\" + \\")) + ((\\" + \\"(\\" + rational_to_string(v[8]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[3]) + \\")\\" + \\")) + (\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * (\\" + \\"(\\" + rational_to_string(v[5]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[7]) + \\")\\" + \\"))))\\";\\n}\\nbool check_input_matrixDeterminant2(const std::vector<double> &v)\\n{\\n    if (-10.0 > v[0])\\n        return false;\\n    if (v[0] > 10.0)\\n        return false;\\n    if (-10.0 > v[1])\\n        return false;\\n    if (v[1] > 10.0)\\n        return false;\\n    if (-10.0 > v[2])\\n        return false;\\n    if (v[2] > 10.0)\\n        return false;\\n    if (-10.0 > v[3])\\n        return false;\\n    if (v[3] > 10.0)\\n        return false;\\n    if (-10.0 > v[4])\\n        return false;\\n    if (v[4] > 10.0)\\n        return false;\\n    if (-10.0 > v[5])\\n        return false;\\n    if (v[5] > 10.0)\\n        return false;\\n    if (-10.0 > v[6])\\n        return false;\\n    if (v[6] > 10.0)\\n        return false;\\n    if (-10.0 > v[7])\\n        return false;\\n    if (v[7] > 10.0)\\n        return false;\\n    if (-10.0 > v[8])\\n        return false;\\n    if (v[8] > 10.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> matrixDeterminant2_range = {std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0), std::uniform_real_distribution<double>(-10.0, 10.0)};\\nconst int matrixDeterminant2_variable_count = 9;","function_name":"matrixDeterminant2","graph_name_base":"matrixDeterminant2","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>2.53e+03</td><td>1.83e+04</td><td>1.60e+04</td><td><b><i>5.37e+02</i></b></td><td>7.56e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>1.49e+03</td><td>1.85e+04</td><td>3.75e+03</td><td><b><i>1.09e+03</i></b></td><td>1.90e+03</td><td>5.75e+03</td><td>5.75e+03</td><td>5.75e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>1.48e+03</td><td>1.99e+03</td><td>5.92e+02</td><td><b><i>4.84e+02</i></b></td><td>6.77e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench Complex square root","expr":"0.5 * sqrt(2.0 * (sqrt((X0 * X0) + (X1 * X1)) + X0))","num_variable":"2","file_name":"Complex_square_root.cpp","code":"// FPBench Complex square root\\ntemplate <class T>\\ninline T Complex_square_root(const std::vector<T> &value_array)\\n{\\n\\treturn 0.5 * sqrt(2.0 * (sqrt((value_array[0] * value_array[0]) + (value_array[1] * value_array[1])) + value_array[0]));\\n}\\nstd::string print_Complex_square_root(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"(1/2) * sqrt((2) * (sqrt((\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\") + (\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * \\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\")) + \\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\"))\\";\\n}\\nbool check_input_Complex_square_root(const std::vector<double> &v)\\n{\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> Complex_square_root_range = {std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX), std::uniform_real_distribution<double>(-RAND_MAX + 1, RAND_MAX)};\\nconst int Complex_square_root_variable_count = 2;","function_name":"Complex_square_root","graph_name_base":"Complex square root","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>1.31e+03</td><td>8.69e+03</td><td>5.98e+03</td><td><b><i>3.70e+02</i></b></td><td>5.21e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>6.22e+02</td><td>1.01e+04</td><td><b><i>3.02e+02</i></b></td><td>5.76e+02</td><td>9.83e+02</td><td>2.33e+03</td><td>2.33e+03</td><td>2.33e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>7.81e+02</td><td>1.04e+03</td><td>4.48e+02</td><td><b><i>3.80e+02</i></b></td><td>5.13e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"},{"description":"FPBench polarToCarthesian, y","expr":"X0 * sin((X1 * ((3.14159265359) / 180.0)))","num_variable":"2","file_name":"polarToCarthesian_y.cpp","code":"// FPBench polarToCarthesian, y\\ntemplate <class T>\\ninline T polarToCarthesian_y(const std::vector<T> &value_array)\\n{\\n\\treturn value_array[0] * sin((value_array[1] * ((3.14159265359) / 180.0)));\\n}\\nstd::string print_polarToCarthesian_y(const std::vector<gmp::Rational> &v)\\n{\\n\\treturn std::string() + \\"\\" + \\"(\\" + rational_to_string(v[0]) + \\")\\" + \\" * sin((\\" + \\"(\\" + rational_to_string(v[1]) + \\")\\" + \\" * (((314159265359/100000000000)) / (180))))\\";\\n}\\nbool check_input_polarToCarthesian_y(const std::vector<double> &v)\\n{\\n    if (1.0 > v[0])\\n        return false;\\n    if (v[0] > 10.0)\\n        return false;\\n    if (0.0 > v[1])\\n        return false;\\n    if (v[1] > 360.0)\\n        return false;\\n    return true;\\n}\\nconst std::vector<std::uniform_real_distribution<double>> polarToCarthesian_y_range = {std::uniform_real_distribution<double>(1.0, 10.0), std::uniform_real_distribution<double>(0.0, 360.0)};\\nconst int polarToCarthesian_y_variable_count = 2;","function_name":"polarToCarthesian_y","graph_name_base":"polarToCarthesian, y","table_html":"<table class=\\"center-table\\"><tr><td></td><td>FILIB C</td><td>BOOST</td><td>NATIVE SWITCHED</td><td>MULTIPLICATIVE</td><td>PRED SUCC</td><td>BIAS UPWARD</td><td>BIAS DOWNWARD</td><td>BIAS NEAR</td></tr><tr><td class=\\"table-left\\">Windows</td><td>6.31e+02</td><td>7.16e+03</td><td>2.16e+03</td><td><b><i>3.32e+02</i></b></td><td>3.50e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">Linux</td><td>4.81e+02</td><td>9.39e+03</td><td>3.88e+02</td><td><b><i>3.08e+02</i></b></td><td>4.27e+02</td><td>3.87e+03</td><td>3.84e+03</td><td>3.84e+03</td></tr><tr><td class=\\"table-left\\">MacOS(x86-64)</td><td>4.82e+02</td><td>1.17e+03</td><td><b><i>3.70e+02</i></b></td><td>3.81e+02</td><td>3.95e+02</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr><tr><td class=\\"table-left\\">MacOS(arm)</td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td><td><span>&#10539;</span></td></tr></table>"}]')},"56d7":function(t,a,n){"use strict";n.r(a);n("e260"),n("e6cf"),n("cca6"),n("a79d");var r=n("2b0e"),d=function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("div",{attrs:{id:"app"}},[n("div",{attrs:{id:"nav"}},[n("router-link",{attrs:{to:"/"}},[t._v("Home")]),t._v(" | "),n("router-link",{attrs:{to:"/benchmarks"}},[t._v("Benchmarks")]),t._v(" | "),n("router-link",{attrs:{to:"/about"}},[t._v("About")]),t._v(" | "),n("router-link",{attrs:{to:"/github",target:"_blank"}},[t._v("Github")])],1),n("transition",{attrs:{name:"fade",mode:"out-in"}},[n("router-view")],1)],1)},e=[],s=(n("034f"),n("2877")),l={},i=Object(s["a"])(l,d,e,!1,null,null,null),_=i.exports,o=(n("d3b7"),n("8c4f")),u=function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("div",{staticClass:"home"},[n("h1",{staticClass:"display-4 text-center",staticStyle:{color:"#bcd6f0"},attrs:{id:"intro-header"}},[t._v(" Interval Benchmarks ")]),t._m(0),t._m(1),n("div",{staticClass:"center-intro"},[n("p",{staticStyle:{"margin-top":"10%",color:"#bcd6f0","font-size":"22px","text-align":"left"}},[t._v(" For more detail of result of benchmark, please go to "),n("router-link",{attrs:{to:"/about"}},[t._v("About")]),t._v(" section. We currently have a total of "+t._s(t.num_benchmark)+" benchmarks. ")],1)])])},p=[function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("div",{staticClass:"center-intro"},[n("p",{staticStyle:{"margin-top":"10%",color:"#bcd6f0","font-size":"22px","text-align":"left"}},[t._v(" A benchmark designed to test the correctness, consistency, portability, interval size and speed of an interval library. "),n("br"),t._v("In this benchmark, we test upon 4 libraries: "),n("a",{staticClass:"intro-href",attrs:{href:"https://www.boost.org/"}},[t._v("BOOST")]),t._v(", "),n("a",{staticClass:"intro-href",attrs:{href:"http://www2.math.uni-wuppertal.de/wrswt/software/filib.html"}},[t._v("filib")]),t._v(", "),n("a",{staticClass:"intro-href",attrs:{href:"http://www2.math.uni-wuppertal.de/wrswt/software/filib.html"}},[t._v("filib++")]),t._v(" and "),n("a",{staticClass:"intro-href",attrs:{href:"http://www.ti3.tu-harburg.de/keil/profil/index_e.html"}},[t._v("BIAS")]),t._v(". For a short summary, here is a nice table: ")])])},function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("div",[n("table",{staticClass:"center-table"},[n("tr",[n("td"),n("td",[t._v("BOOST")]),n("td",[t._v("FILIB")]),n("td",[t._v("NATIVE SWITCHED")]),n("td",[t._v("MULTIPLICATIVE")]),n("td",[t._v("PRED-SUCC")]),n("td",[t._v("BIAS")])]),n("tr",[n("td",{staticClass:"table-left"},[t._v("CORRECTNESS(ARITHMETIC)")]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])])]),n("tr",[n("td",{staticClass:"table-left"},[t._v("CORRECTNESS(TRANSCENDENTAL)")]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])])]),n("tr",[n("td",{staticClass:"table-left"},[t._v("CORRECTNESS(COMPOSITE)")]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("⤫")])])]),n("tr",[n("td",{staticClass:"table-left"},[t._v("INTERVAL SIZE(ARITHMETIC)")]),n("td",[t._v("1")]),n("td",[t._v("2")]),n("td",[t._v("1")]),n("td",[t._v("3")]),n("td",[t._v("2")]),n("td",[t._v("1")])]),n("tr",[n("td",{staticClass:"table-left"},[t._v("INTERVAL SIZE(TRANSCENDENTAL)")]),n("td",[t._v("1")]),n("td",[t._v("2")]),n("td",[t._v("2")]),n("td",[t._v("2")]),n("td",[t._v("2")]),n("td",[t._v("1")])]),n("tr",[n("td",{staticClass:"table-left"},[t._v("SPEED")]),n("td",[t._v("6")]),n("td",[t._v("3")]),n("td",[t._v("4")]),n("td",[t._v("1")]),n("td",[t._v("2")]),n("td",[t._v("5")])]),n("tr",[n("td",{staticClass:"table-left"},[t._v("CONSISTENCY")]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("⤫")])])]),n("tr",[n("td",{staticClass:"table-left"},[t._v("PORTABILITY")]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("✓")])]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("⤫")])]),n("td",[n("span",[t._v("⤫")])])])])])}],v={name:"Home",components:{},data:function(){return{num_benchmark:10}},mounted:function(){var t=n("40ca");this.num_benchmark=t.length,console.log(this.num_benchmark)}},c=v,b=(n("1d87"),Object(s["a"])(c,u,p,!1,null,"57ab8395",null)),f=b.exports;r["a"].use(o["a"]);var m=[{path:"/",name:"Home",component:f},{path:"/benchmarks",name:"Benchmarks",component:function(){return n.e("about").then(n.bind(null,"12d3"))}},{path:"/about",name:"About",component:function(){return n.e("about").then(n.bind(null,"f820"))}},{path:"/github",beforeEnter:function(){location.href="https://github.com/geometryprocessing/intervals"}}],g=new o["a"]({routes:m}),y=g,A=n("2f62");r["a"].use(A["a"]);var X=new A["a"].Store({state:{},mutations:{},actions:{},modules:{}}),S=n("f309");r["a"].use(S["a"]);var I=new S["a"]({}),T=n("998c"),R=n.n(T);r["a"].use(R.a),r["a"].config.productionTip=!1,new r["a"]({router:y,store:X,vuetify:I,render:function(t){return t(_)}}).$mount("#app")},"5b18":function(t,a,n){},"85ec":function(t,a,n){}});
//# sourceMappingURL=app.73f81121.js.map